<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage">
  <head>
    

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

  <title>Records - Records</title>
  <meta property="og:title" content="Records" />
  <meta name="twitter:title" content="Records" />
  <meta name="description" content="&emsp;&emsp;netty是一个用于客户端和服务器通信的高性能网络通信框架，涉及到跨机器之间的通信，必然离不开I/O，所以我们就从Java 的I/O演变之路开始讨论吧。
引出一个话题：什么是I/O，或者这么说，一次I/O究竟发生了哪些事情？我们从三个层面来理解一下I/O： 1. 从直观上来看：I/O是计算机和外部设备之间的数据流动过程。计算机即是我们平日里随处可见的一台机器，外部设备大体上又包括输入设备和输出设备。比如，键盘、鼠标就属于输入设备；显示器属于输出设备。 2. 从计算机架构的层面来看：任何涉及到计算机核心（CPU和内存）与其他设备之间的数据转移就是I/O。本体就是计算机核心（CPU和内存）。例如从硬盘上读取数据到内存，是一次输入，将内存中的数据写入到硬盘就产生了输出。在计算机的世界里，这就是I/O的本质。 3. 从程序员编程的角度来看：此时，I/O的主体是我们编写的应用程序（即进程），需要注意的是，我们编写的应用程序其实并不存在实质的I/O过程，真正的I/O是操作系统的任务（用户态和内核态）。我们将应用程序代码的I/O细分为两个动作：I/O调用和I/O执行。I/O调用由应用程序（进程）发起的，而I/O执行是操作系统完成的（这就是系统调用），我们代码里写一个read()函数，实质上包含了我们程序发起的I/O调用，在看不见的地方，还有一次I/O执行（操作系统所完成的系统调用）。 I/O调用的目的是将进程的内部数据迁移到外部即输出，或将外部数据迁移到进程内部即输入(应用程序是主体)。这里，外部数据指非进程空间数据，在编程时，通常讨论的场景是来自外部存储设备的数据，如硬盘、CD-ROM、以及需要socket通信传输的网络数据。 我们来看一次典型的I/O输入会发生什么事情，以一个进程的输入类型的IO调用为例，它的工作内容如下：
 进程向操作系统请求外部数据——&gt;I/O调用 操作系统将外部数据加载到内核缓冲区———&gt;I/O执行 操作系统将数据从内核缓冲区拷贝到进程缓冲区———&gt;I/O执行 进程读取数据继续后面的工作
接下来我们来对比两组常见的概念
阻塞I/O和非阻塞I/O 阻塞和非阻塞强调的是进程对于操作系统IO是否处于就绪状态的处理方式。
上面已经说过，应用程序的IO实际是分为两个步骤，IO调用和IO执行。IO调用是由进程发起，IO执行是操作系统的工作。操作系统的IO情况决定了进程IO调用是否能够得到立即响应。如进程发起了读取数据的IO调用，操作系统需要将外部数据拷贝到进程缓冲区，在有数据拷贝到进程缓冲区前，进程缓冲区处于不可读状态，我们称之为操作系统IO未就绪。 进程的IO调用是否能得到立即执行是需要操作系统IO处于就绪状态的，对于读取数据的操作，如果操作系统IO处于未就绪状态，当前进程或线程如果一直等待直到其就绪，该种IO方式为阻塞IO。如果进程或线程并不一直等待其就绪，而是可以做其他事情，这种方式为非阻塞IO。所以对于非阻塞IO，我们编程时需要经常去轮询就绪状态。
同步I/O和异步I/O 我们经常会谈及同步IO和异步IO。同步和异步描述的是针对当前执行线程、或进程而言，发起IO调用后，当前线程或进程是否挂起等待操作系统的IO执行完成。 我们说一个IO执行是同步执行的，意思是程序发起IO调用，当前线程或进程需要等待操作系统完成IO工作并告知进程已经完成，线程或进程才能继续往下执行其他既定指令。 如果说一个IO执行是异步的，意思是该动作是由当前线程或进程请求发起，且当前线程或进程不必等待操作系统IO的执行完毕，可直接继续往下执行其他既定指令。操作系统完成IO后，当前线程或进程会得到操作系统的通知。 以一个读取数据的IO操作而言，在操作系统将外部数据写入进程缓冲区这个期间，进程或线程挂起等待操作系统IO执行完成的话，这种IO执行策略就为同步，如果进程或线程并不挂起而是继续工作，这种IO执行策略便为异步。
总结：在IO调用时，对待操作系统IO就绪状态的不同方式，决定了其是阻塞或非阻塞模式；在IO执行时，线程或进程是否挂起等待IO执行决定了其是否为同步或异步IO。  在JDK引进NIO（Non-Blocking IO）之前，Java的I/O是阻塞式，都是面向流的，大体上可以分为两类：
- 基于字节流的InputStream和OutputStream
- 基于字符流的Reader和Writer
字符和字节之间的转换对应的就是编码和解码。在这个时期Java的IO是同步阻塞的（attention：同步和阻塞不是一个概念，他们是不同维度的），且只有输出流和输入流，没有channe、buffer等，效率很低。 Java NIO中文版这本书剖析了Java NIO，清晰易懂，推荐阅读。
这里，我们借用权威书《UNIX 网络编程：卷一》中的内容，来讨论Linux下的5种I/O模型。
对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所有等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用程序缓冲区。 好，下面我们以阻塞套接字的recvfrom的的调用图来说明。
###1、阻塞I/O模型
如图所示，这是最常用的I/O模型，缺省情况下所有的文件操作都是阻塞的，事实上，网络I/O也是文件I/O的一种（SocketOutputStream是FileOutputStream的子类）。在进程空间发起recvfrom调用（一次I/O调用）；此时转到操作系统内核，操作系统内核将数据加载到内核缓冲区（一次I/O执行），这段时间应用进程阻塞住，等待数据准备好；然后由操作系统将数据从内核缓冲区拷贝至用户进程缓冲区（I/O执行），这段时间应用进程仍然处于阻塞状态，等待数据拷贝完成；一旦拷贝完成，操作系统内核就告知用户进程，调用成功返回。由此图我们可以得知，阻塞I/O模型在两个时间段都是被阻塞的。  ###2、非阻塞I/O模型
还是截了一张书中的图，可以看到，应用进程在发起recvfrom调用的时候，如果发现操作系统内核还没有把数据准备好（即操作系统内核缓冲区中还没有数据），那么就直接返回一个EWOULDBLOCK错误，这种模式的一个问题就是你需要隔段时间去轮询一次，看操作系统内核缓冲区中是否有数据到来；一旦内核缓冲区准备好数据，那么调用开始阻塞，等待操作系统将内核缓冲区中的数据拷贝到用户空间中去，这段时间进程仍然是被阻塞住的，直到拷贝完成才能返回。
由此我们得出结论：阻塞和非阻塞I/O的区别在于是否需要等待操作系统将外部数据加载到内核缓冲区，即前面提到的第一次I/O执行。  ###3、I/O多路复用模型
I/O多路复用的基本原理是：将多个I/O的阻塞复用到对一个select的阻塞上，实现一个线程处理多个请求，它的核心在于多路复用器Selector，多个socket可以注册到一个Selector上，这个selector去轮询它所负责的socket，发现某一个socket的数据准备好了后就返回，然后去执行系统调用recvfrom。图中我们可以看出来，虽然I/O多路复用的函数也是阻塞的，但是其与以上两种还是有不同的，I/O多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用如recvfrom之上（所以两个系统调用，花费也更大，IO多路复用的性能是有可能比BIO还差的，但其优势在于处理多个连接，参考C10k问题）。
图中显示的系统调用是select，这就不得不引入到我们经典的几个系统调用（select、poll、epoll），这是需要单独的一篇文章来介绍三种调用的不同之处，当然它们的思想都是一致的。
深入理解select、epoll 当然最好还是看Linux内核书籍
注意：当selector轮询到某一个socket可读时，它返回，然后用户进程执行系统调用recvfrom，这个时候就又回到了我们的前两种I/O模型，此时，往往都采用的是NIO方式，因为尽管select返回了，告知用户进程某个socket可读，但并不告诉我们能读的数据有多少，甚至并不意味着我们接着调用recvfrom就能读到数据，所以I/O多路复用一般得搭配NIO。参考： &gt;为什么 IO 多路复用要搭配非阻塞 IO? &gt;使用epoll时需要将socket设为非阻塞吗？ 
###4、信号驱动模型 摘抄自《权威指南书》，首先开启套接口的信号驱动功能，并通过系统调用sigaction执行一个信号处理函数（此系统调用立即返回，用户进程继续工作）；当数据准备就绪时，就为该进程生成一个SIGIO信号，通过信号回调通知应用进程调用recvfrom接口来读取数据。 
###5、异步I/O模型 见识一下什么叫真正的异步I/O模型，直接告知内核开启某个操作，并让内核完成整个流程后（包括将数据准备好——拷贝到内核缓冲区，然后将数据从内和缓冲区复制到用户进程缓冲区）。信号驱动模型由内核通知我们什么时候可以开启一个I/O操作，而异步I/O模型直接告诉我们I/O操作已经完成了。 推荐书：Unix网络编程 
这就是传说中的五种Linux I/O模型，下一篇文章我们详细分析一下I/O多路复用模型，重点关注epoll。">
  <meta property="og:description" content="&emsp;&emsp;netty是一个用于客户端和服务器通信的高性能网络通信框架，涉及到跨机器之间的通信，必然离不开I/O，所以我们就从Java 的I/O演变之路开始讨论吧。
引出一个话题：什么是I/O，或者这么说，一次I/O究竟发生了哪些事情？我们从三个层面来理解一下I/O： 1. 从直观上来看：I/O是计算机和外部设备之间的数据流动过程。计算机即是我们平日里随处可见的一台机器，外部设备大体上又包括输入设备和输出设备。比如，键盘、鼠标就属于输入设备；显示器属于输出设备。 2. 从计算机架构的层面来看：任何涉及到计算机核心（CPU和内存）与其他设备之间的数据转移就是I/O。本体就是计算机核心（CPU和内存）。例如从硬盘上读取数据到内存，是一次输入，将内存中的数据写入到硬盘就产生了输出。在计算机的世界里，这就是I/O的本质。 3. 从程序员编程的角度来看：此时，I/O的主体是我们编写的应用程序（即进程），需要注意的是，我们编写的应用程序其实并不存在实质的I/O过程，真正的I/O是操作系统的任务（用户态和内核态）。我们将应用程序代码的I/O细分为两个动作：I/O调用和I/O执行。I/O调用由应用程序（进程）发起的，而I/O执行是操作系统完成的（这就是系统调用），我们代码里写一个read()函数，实质上包含了我们程序发起的I/O调用，在看不见的地方，还有一次I/O执行（操作系统所完成的系统调用）。 I/O调用的目的是将进程的内部数据迁移到外部即输出，或将外部数据迁移到进程内部即输入(应用程序是主体)。这里，外部数据指非进程空间数据，在编程时，通常讨论的场景是来自外部存储设备的数据，如硬盘、CD-ROM、以及需要socket通信传输的网络数据。 我们来看一次典型的I/O输入会发生什么事情，以一个进程的输入类型的IO调用为例，它的工作内容如下：
 进程向操作系统请求外部数据——&gt;I/O调用 操作系统将外部数据加载到内核缓冲区———&gt;I/O执行 操作系统将数据从内核缓冲区拷贝到进程缓冲区———&gt;I/O执行 进程读取数据继续后面的工作
接下来我们来对比两组常见的概念
阻塞I/O和非阻塞I/O 阻塞和非阻塞强调的是进程对于操作系统IO是否处于就绪状态的处理方式。
上面已经说过，应用程序的IO实际是分为两个步骤，IO调用和IO执行。IO调用是由进程发起，IO执行是操作系统的工作。操作系统的IO情况决定了进程IO调用是否能够得到立即响应。如进程发起了读取数据的IO调用，操作系统需要将外部数据拷贝到进程缓冲区，在有数据拷贝到进程缓冲区前，进程缓冲区处于不可读状态，我们称之为操作系统IO未就绪。 进程的IO调用是否能得到立即执行是需要操作系统IO处于就绪状态的，对于读取数据的操作，如果操作系统IO处于未就绪状态，当前进程或线程如果一直等待直到其就绪，该种IO方式为阻塞IO。如果进程或线程并不一直等待其就绪，而是可以做其他事情，这种方式为非阻塞IO。所以对于非阻塞IO，我们编程时需要经常去轮询就绪状态。
同步I/O和异步I/O 我们经常会谈及同步IO和异步IO。同步和异步描述的是针对当前执行线程、或进程而言，发起IO调用后，当前线程或进程是否挂起等待操作系统的IO执行完成。 我们说一个IO执行是同步执行的，意思是程序发起IO调用，当前线程或进程需要等待操作系统完成IO工作并告知进程已经完成，线程或进程才能继续往下执行其他既定指令。 如果说一个IO执行是异步的，意思是该动作是由当前线程或进程请求发起，且当前线程或进程不必等待操作系统IO的执行完毕，可直接继续往下执行其他既定指令。操作系统完成IO后，当前线程或进程会得到操作系统的通知。 以一个读取数据的IO操作而言，在操作系统将外部数据写入进程缓冲区这个期间，进程或线程挂起等待操作系统IO执行完成的话，这种IO执行策略就为同步，如果进程或线程并不挂起而是继续工作，这种IO执行策略便为异步。
总结：在IO调用时，对待操作系统IO就绪状态的不同方式，决定了其是阻塞或非阻塞模式；在IO执行时，线程或进程是否挂起等待IO执行决定了其是否为同步或异步IO。  在JDK引进NIO（Non-Blocking IO）之前，Java的I/O是阻塞式，都是面向流的，大体上可以分为两类：
- 基于字节流的InputStream和OutputStream
- 基于字符流的Reader和Writer
字符和字节之间的转换对应的就是编码和解码。在这个时期Java的IO是同步阻塞的（attention：同步和阻塞不是一个概念，他们是不同维度的），且只有输出流和输入流，没有channe、buffer等，效率很低。 Java NIO中文版这本书剖析了Java NIO，清晰易懂，推荐阅读。
这里，我们借用权威书《UNIX 网络编程：卷一》中的内容，来讨论Linux下的5种I/O模型。
对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所有等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用程序缓冲区。 好，下面我们以阻塞套接字的recvfrom的的调用图来说明。
###1、阻塞I/O模型
如图所示，这是最常用的I/O模型，缺省情况下所有的文件操作都是阻塞的，事实上，网络I/O也是文件I/O的一种（SocketOutputStream是FileOutputStream的子类）。在进程空间发起recvfrom调用（一次I/O调用）；此时转到操作系统内核，操作系统内核将数据加载到内核缓冲区（一次I/O执行），这段时间应用进程阻塞住，等待数据准备好；然后由操作系统将数据从内核缓冲区拷贝至用户进程缓冲区（I/O执行），这段时间应用进程仍然处于阻塞状态，等待数据拷贝完成；一旦拷贝完成，操作系统内核就告知用户进程，调用成功返回。由此图我们可以得知，阻塞I/O模型在两个时间段都是被阻塞的。  ###2、非阻塞I/O模型
还是截了一张书中的图，可以看到，应用进程在发起recvfrom调用的时候，如果发现操作系统内核还没有把数据准备好（即操作系统内核缓冲区中还没有数据），那么就直接返回一个EWOULDBLOCK错误，这种模式的一个问题就是你需要隔段时间去轮询一次，看操作系统内核缓冲区中是否有数据到来；一旦内核缓冲区准备好数据，那么调用开始阻塞，等待操作系统将内核缓冲区中的数据拷贝到用户空间中去，这段时间进程仍然是被阻塞住的，直到拷贝完成才能返回。
由此我们得出结论：阻塞和非阻塞I/O的区别在于是否需要等待操作系统将外部数据加载到内核缓冲区，即前面提到的第一次I/O执行。  ###3、I/O多路复用模型
I/O多路复用的基本原理是：将多个I/O的阻塞复用到对一个select的阻塞上，实现一个线程处理多个请求，它的核心在于多路复用器Selector，多个socket可以注册到一个Selector上，这个selector去轮询它所负责的socket，发现某一个socket的数据准备好了后就返回，然后去执行系统调用recvfrom。图中我们可以看出来，虽然I/O多路复用的函数也是阻塞的，但是其与以上两种还是有不同的，I/O多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用如recvfrom之上（所以两个系统调用，花费也更大，IO多路复用的性能是有可能比BIO还差的，但其优势在于处理多个连接，参考C10k问题）。
图中显示的系统调用是select，这就不得不引入到我们经典的几个系统调用（select、poll、epoll），这是需要单独的一篇文章来介绍三种调用的不同之处，当然它们的思想都是一致的。
深入理解select、epoll 当然最好还是看Linux内核书籍
注意：当selector轮询到某一个socket可读时，它返回，然后用户进程执行系统调用recvfrom，这个时候就又回到了我们的前两种I/O模型，此时，往往都采用的是NIO方式，因为尽管select返回了，告知用户进程某个socket可读，但并不告诉我们能读的数据有多少，甚至并不意味着我们接着调用recvfrom就能读到数据，所以I/O多路复用一般得搭配NIO。参考： &gt;为什么 IO 多路复用要搭配非阻塞 IO? &gt;使用epoll时需要将socket设为非阻塞吗？ 
###4、信号驱动模型 摘抄自《权威指南书》，首先开启套接口的信号驱动功能，并通过系统调用sigaction执行一个信号处理函数（此系统调用立即返回，用户进程继续工作）；当数据准备就绪时，就为该进程生成一个SIGIO信号，通过信号回调通知应用进程调用recvfrom接口来读取数据。 
###5、异步I/O模型 见识一下什么叫真正的异步I/O模型，直接告知内核开启某个操作，并让内核完成整个流程后（包括将数据准备好——拷贝到内核缓冲区，然后将数据从内和缓冲区复制到用户进程缓冲区）。信号驱动模型由内核通知我们什么时候可以开启一个I/O操作，而异步I/O模型直接告诉我们I/O操作已经完成了。 推荐书：Unix网络编程 
这就是传说中的五种Linux I/O模型，下一篇文章我们详细分析一下I/O多路复用模型，重点关注epoll。">
  <meta name="twitter:description" content="&emsp;&emsp;netty是一个用于客户端和服务器通信的高性能网络通信框架，涉及到跨机器之间的通信，必然离不开I/O，所以我们就从Java 的I/O演变之路开始讨论吧。
引出一个话题：什么是I/O，或者这么说，一次I/O究竟发生了哪些事情？我们从三个层面来理解一下I/O： 1. 从直观上来看：I/O是计算机和外部设备之间的数据流动过程。计算机即是我们平日里随处可见的一台机器，外部设备大体上 …"><script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "WebSite",
    "name": "Records",
    
    "url": "https:\/\/monkback.github.io"
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Organization",
  "name": "",
  "url": "https:\/\/monkback.github.io"
  
  
  
  
}
</script>
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
        "@type": "ListItem",
        "position": 1,
        "item": {
          "@id": "https:\/\/monkback.github.io",
          "name": "home"
        }
    },{
        "@type": "ListItem",
        "position": 3,
        "item": {
          "@id": "https:\/\/monkback.github.io\/posts\/%E4%B8%80\/",
          "name": ""
        }
    }]
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Article",
  "author": {
    "name" : ""
  },
  "headline": "",
  "description" : "\x26emsp;\x26emsp;netty是一个用于客户端和服务器通信的高性能网络通信框架，涉及到跨机器之间的通信，必然离不开I\/O，所以我们就从Java 的I\/O演变之路开始讨论吧。\n引出一个话题：什么是I\/O，或者这么说，一次I\/O究竟发生了哪些事情？我们从三个层面来理解一下I\/O： 1. 从直观上来看：I\/O是计算机和外部设备之间的数据流动过程。计算机即是我们平日里随处可见的一台机器，外部设备大体上又包括输入设备和输出设备。比如，键盘、鼠标就属于输入设备；显示器属于输出设备。 2. 从计算机架构的层面来看：任何涉及到计算机核心（CPU和内存）与其他设备之间的数据转移就是I\/O。本体就是计算机核心（CPU和内存）。例如从硬盘上读取数据到内存，是一次输入，将内存中的数据写入到硬盘就产生了输出。在计算机的世界里，这就是I\/O的本质。 3. 从程序员编程的角度来看：此时，I\/O的主体是我们编写的应用程序（即进程），需要注意的是，我们编写的应用程序其实并不存在实质的I\/O过程，真正的I\/O是操作系统的任务（用户态和内核态）。我们将应用程序代码的I\/O细分为两个动作：I\/O调用和I\/O执行。I\/O调用由应用程序（进程）发起的，而I\/O执行是操作系统完成的（这就是系统调用），我们代码里写一个read()函数，实质上包含了我们程序发起的I\/O调用，在看不见的地方，还有一次I\/O执行（操作系统所完成的系统调用）。 I\/O调用的目的是将进程的内部数据迁移到外部即输出，或将外部数据迁移到进程内部即输入(应用程序是主体)。这里，外部数据指非进程空间数据，在编程时，通常讨论的场景是来自外部存储设备的数据，如硬盘、CD-ROM、以及需要socket通信传输的网络数据。 我们来看一次典型的I\/O输入会发生什么事情，以一个进程的输入类型的IO调用为例，它的工作内容如下：\n 进程向操作系统请求外部数据——\x26gt;I\/O调用 操作系统将外部数据加载到内核缓冲区———\x26gt;I\/O执行 操作系统将数据从内核缓冲区拷贝到进程缓冲区———\x26gt;I\/O执行 进程读取数据继续后面的工作\n接下来我们来对比两组常见的概念\n阻塞I\/O和非阻塞I\/O 阻塞和非阻塞强调的是进程对于操作系统IO是否处于就绪状态的处理方式。\n上面已经说过，应用程序的IO实际是分为两个步骤，IO调用和IO执行。IO调用是由进程发起，IO执行是操作系统的工作。操作系统的IO情况决定了进程IO调用是否能够得到立即响应。如进程发起了读取数据的IO调用，操作系统需要将外部数据拷贝到进程缓冲区，在有数据拷贝到进程缓冲区前，进程缓冲区处于不可读状态，我们称之为操作系统IO未就绪。 进程的IO调用是否能得到立即执行是需要操作系统IO处于就绪状态的，对于读取数据的操作，如果操作系统IO处于未就绪状态，当前进程或线程如果一直等待直到其就绪，该种IO方式为阻塞IO。如果进程或线程并不一直等待其就绪，而是可以做其他事情，这种方式为非阻塞IO。所以对于非阻塞IO，我们编程时需要经常去轮询就绪状态。\n同步I\/O和异步I\/O 我们经常会谈及同步IO和异步IO。同步和异步描述的是针对当前执行线程、或进程而言，发起IO调用后，当前线程或进程是否挂起等待操作系统的IO执行完成。 我们说一个IO执行是同步执行的，意思是程序发起IO调用，当前线程或进程需要等待操作系统完成IO工作并告知进程已经完成，线程或进程才能继续往下执行其他既定指令。 如果说一个IO执行是异步的，意思是该动作是由当前线程或进程请求发起，且当前线程或进程不必等待操作系统IO的执行完毕，可直接继续往下执行其他既定指令。操作系统完成IO后，当前线程或进程会得到操作系统的通知。 以一个读取数据的IO操作而言，在操作系统将外部数据写入进程缓冲区这个期间，进程或线程挂起等待操作系统IO执行完成的话，这种IO执行策略就为同步，如果进程或线程并不挂起而是继续工作，这种IO执行策略便为异步。\n总结：在IO调用时，对待操作系统IO就绪状态的不同方式，决定了其是阻塞或非阻塞模式；在IO执行时，线程或进程是否挂起等待IO执行决定了其是否为同步或异步IO。  在JDK引进NIO（Non-Blocking IO）之前，Java的I\/O是阻塞式，都是面向流的，大体上可以分为两类：\n- 基于字节流的InputStream和OutputStream\n- 基于字符流的Reader和Writer\n字符和字节之间的转换对应的就是编码和解码。在这个时期Java的IO是同步阻塞的（attention：同步和阻塞不是一个概念，他们是不同维度的），且只有输出流和输入流，没有channe、buffer等，效率很低。 Java NIO中文版这本书剖析了Java NIO，清晰易懂，推荐阅读。\n这里，我们借用权威书《UNIX 网络编程：卷一》中的内容，来讨论Linux下的5种I\/O模型。\n对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所有等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用程序缓冲区。 好，下面我们以阻塞套接字的recvfrom的的调用图来说明。\n###1、阻塞I\/O模型\n如图所示，这是最常用的I\/O模型，缺省情况下所有的文件操作都是阻塞的，事实上，网络I\/O也是文件I\/O的一种（SocketOutputStream是FileOutputStream的子类）。在进程空间发起recvfrom调用（一次I\/O调用）；此时转到操作系统内核，操作系统内核将数据加载到内核缓冲区（一次I\/O执行），这段时间应用进程阻塞住，等待数据准备好；然后由操作系统将数据从内核缓冲区拷贝至用户进程缓冲区（I\/O执行），这段时间应用进程仍然处于阻塞状态，等待数据拷贝完成；一旦拷贝完成，操作系统内核就告知用户进程，调用成功返回。由此图我们可以得知，阻塞I\/O模型在两个时间段都是被阻塞的。  ###2、非阻塞I\/O模型\n还是截了一张书中的图，可以看到，应用进程在发起recvfrom调用的时候，如果发现操作系统内核还没有把数据准备好（即操作系统内核缓冲区中还没有数据），那么就直接返回一个EWOULDBLOCK错误，这种模式的一个问题就是你需要隔段时间去轮询一次，看操作系统内核缓冲区中是否有数据到来；一旦内核缓冲区准备好数据，那么调用开始阻塞，等待操作系统将内核缓冲区中的数据拷贝到用户空间中去，这段时间进程仍然是被阻塞住的，直到拷贝完成才能返回。\n由此我们得出结论：阻塞和非阻塞I\/O的区别在于是否需要等待操作系统将外部数据加载到内核缓冲区，即前面提到的第一次I\/O执行。  ###3、I\/O多路复用模型\nI\/O多路复用的基本原理是：将多个I\/O的阻塞复用到对一个select的阻塞上，实现一个线程处理多个请求，它的核心在于多路复用器Selector，多个socket可以注册到一个Selector上，这个selector去轮询它所负责的socket，发现某一个socket的数据准备好了后就返回，然后去执行系统调用recvfrom。图中我们可以看出来，虽然I\/O多路复用的函数也是阻塞的，但是其与以上两种还是有不同的，I\/O多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I\/O系统调用如recvfrom之上（所以两个系统调用，花费也更大，IO多路复用的性能是有可能比BIO还差的，但其优势在于处理多个连接，参考C10k问题）。\n图中显示的系统调用是select，这就不得不引入到我们经典的几个系统调用（select、poll、epoll），这是需要单独的一篇文章来介绍三种调用的不同之处，当然它们的思想都是一致的。\n深入理解select、epoll 当然最好还是看Linux内核书籍\n注意：当selector轮询到某一个socket可读时，它返回，然后用户进程执行系统调用recvfrom，这个时候就又回到了我们的前两种I\/O模型，此时，往往都采用的是NIO方式，因为尽管select返回了，告知用户进程某个socket可读，但并不告诉我们能读的数据有多少，甚至并不意味着我们接着调用recvfrom就能读到数据，所以I\/O多路复用一般得搭配NIO。参考： \x26gt;为什么 IO 多路复用要搭配非阻塞 IO? \x26gt;使用epoll时需要将socket设为非阻塞吗？ \n###4、信号驱动模型 摘抄自《权威指南书》，首先开启套接口的信号驱动功能，并通过系统调用sigaction执行一个信号处理函数（此系统调用立即返回，用户进程继续工作）；当数据准备就绪时，就为该进程生成一个SIGIO信号，通过信号回调通知应用进程调用recvfrom接口来读取数据。 \n###5、异步I\/O模型 见识一下什么叫真正的异步I\/O模型，直接告知内核开启某个操作，并让内核完成整个流程后（包括将数据准备好——拷贝到内核缓冲区，然后将数据从内和缓冲区复制到用户进程缓冲区）。信号驱动模型由内核通知我们什么时候可以开启一个I\/O操作，而异步I\/O模型直接告诉我们I\/O操作已经完成了。 推荐书：Unix网络编程 \n这就是传说中的五种Linux I\/O模型，下一篇文章我们详细分析一下I\/O多路复用模型，重点关注epoll。",
  "inLanguage" : "en",
  "wordCount":  63 ,
  "datePublished" : "0001-01-01T00:00:00",
  "dateModified" : "0001-01-01T00:00:00",
  "image" : "https:\/\/monkback.github.io",
  "keywords" : [ "" ],
  "mainEntityOfPage" : "https:\/\/monkback.github.io\/posts\/%E4%B8%80\/",
  "publisher" : {
    "@type": "Organization",
    "name" : "https:\/\/monkback.github.io",
    "logo" : {
        "@type" : "ImageObject",
        "url" : "https:\/\/monkback.github.io",
        "height" :  60 ,
        "width" :  60
    }
  }
}
</script>

<meta property="og:title" content="Records" />
<meta property="og:description" content="&emsp;&emsp;netty是一个用于客户端和服务器通信的高性能网络通信框架，涉及到跨机器之间的通信，必然离不开I/O，所以我们就从Java 的I/O演变之路开始讨论吧。
引出一个话题：什么是I/O，或者这么说，一次I/O究竟发生了哪些事情？我们从三个层面来理解一下I/O： 1. 从直观上来看：I/O是计算机和外部设备之间的数据流动过程。计算机即是我们平日里随处可见的一台机器，外部设备大体上又包括输入设备和输出设备。比如，键盘、鼠标就属于输入设备；显示器属于输出设备。 2. 从计算机架构的层面来看：任何涉及到计算机核心（CPU和内存）与其他设备之间的数据转移就是I/O。本体就是计算机核心（CPU和内存）。例如从硬盘上读取数据到内存，是一次输入，将内存中的数据写入到硬盘就产生了输出。在计算机的世界里，这就是I/O的本质。 3. 从程序员编程的角度来看：此时，I/O的主体是我们编写的应用程序（即进程），需要注意的是，我们编写的应用程序其实并不存在实质的I/O过程，真正的I/O是操作系统的任务（用户态和内核态）。我们将应用程序代码的I/O细分为两个动作：I/O调用和I/O执行。I/O调用由应用程序（进程）发起的，而I/O执行是操作系统完成的（这就是系统调用），我们代码里写一个read()函数，实质上包含了我们程序发起的I/O调用，在看不见的地方，还有一次I/O执行（操作系统所完成的系统调用）。 I/O调用的目的是将进程的内部数据迁移到外部即输出，或将外部数据迁移到进程内部即输入(应用程序是主体)。这里，外部数据指非进程空间数据，在编程时，通常讨论的场景是来自外部存储设备的数据，如硬盘、CD-ROM、以及需要socket通信传输的网络数据。 我们来看一次典型的I/O输入会发生什么事情，以一个进程的输入类型的IO调用为例，它的工作内容如下：
 进程向操作系统请求外部数据——&gt;I/O调用 操作系统将外部数据加载到内核缓冲区———&gt;I/O执行 操作系统将数据从内核缓冲区拷贝到进程缓冲区———&gt;I/O执行 进程读取数据继续后面的工作
接下来我们来对比两组常见的概念
阻塞I/O和非阻塞I/O 阻塞和非阻塞强调的是进程对于操作系统IO是否处于就绪状态的处理方式。
上面已经说过，应用程序的IO实际是分为两个步骤，IO调用和IO执行。IO调用是由进程发起，IO执行是操作系统的工作。操作系统的IO情况决定了进程IO调用是否能够得到立即响应。如进程发起了读取数据的IO调用，操作系统需要将外部数据拷贝到进程缓冲区，在有数据拷贝到进程缓冲区前，进程缓冲区处于不可读状态，我们称之为操作系统IO未就绪。 进程的IO调用是否能得到立即执行是需要操作系统IO处于就绪状态的，对于读取数据的操作，如果操作系统IO处于未就绪状态，当前进程或线程如果一直等待直到其就绪，该种IO方式为阻塞IO。如果进程或线程并不一直等待其就绪，而是可以做其他事情，这种方式为非阻塞IO。所以对于非阻塞IO，我们编程时需要经常去轮询就绪状态。
同步I/O和异步I/O 我们经常会谈及同步IO和异步IO。同步和异步描述的是针对当前执行线程、或进程而言，发起IO调用后，当前线程或进程是否挂起等待操作系统的IO执行完成。 我们说一个IO执行是同步执行的，意思是程序发起IO调用，当前线程或进程需要等待操作系统完成IO工作并告知进程已经完成，线程或进程才能继续往下执行其他既定指令。 如果说一个IO执行是异步的，意思是该动作是由当前线程或进程请求发起，且当前线程或进程不必等待操作系统IO的执行完毕，可直接继续往下执行其他既定指令。操作系统完成IO后，当前线程或进程会得到操作系统的通知。 以一个读取数据的IO操作而言，在操作系统将外部数据写入进程缓冲区这个期间，进程或线程挂起等待操作系统IO执行完成的话，这种IO执行策略就为同步，如果进程或线程并不挂起而是继续工作，这种IO执行策略便为异步。
总结：在IO调用时，对待操作系统IO就绪状态的不同方式，决定了其是阻塞或非阻塞模式；在IO执行时，线程或进程是否挂起等待IO执行决定了其是否为同步或异步IO。  在JDK引进NIO（Non-Blocking IO）之前，Java的I/O是阻塞式，都是面向流的，大体上可以分为两类：
- 基于字节流的InputStream和OutputStream
- 基于字符流的Reader和Writer
字符和字节之间的转换对应的就是编码和解码。在这个时期Java的IO是同步阻塞的（attention：同步和阻塞不是一个概念，他们是不同维度的），且只有输出流和输入流，没有channe、buffer等，效率很低。 Java NIO中文版这本书剖析了Java NIO，清晰易懂，推荐阅读。
这里，我们借用权威书《UNIX 网络编程：卷一》中的内容，来讨论Linux下的5种I/O模型。
对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所有等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用程序缓冲区。 好，下面我们以阻塞套接字的recvfrom的的调用图来说明。
###1、阻塞I/O模型
如图所示，这是最常用的I/O模型，缺省情况下所有的文件操作都是阻塞的，事实上，网络I/O也是文件I/O的一种（SocketOutputStream是FileOutputStream的子类）。在进程空间发起recvfrom调用（一次I/O调用）；此时转到操作系统内核，操作系统内核将数据加载到内核缓冲区（一次I/O执行），这段时间应用进程阻塞住，等待数据准备好；然后由操作系统将数据从内核缓冲区拷贝至用户进程缓冲区（I/O执行），这段时间应用进程仍然处于阻塞状态，等待数据拷贝完成；一旦拷贝完成，操作系统内核就告知用户进程，调用成功返回。由此图我们可以得知，阻塞I/O模型在两个时间段都是被阻塞的。  ###2、非阻塞I/O模型
还是截了一张书中的图，可以看到，应用进程在发起recvfrom调用的时候，如果发现操作系统内核还没有把数据准备好（即操作系统内核缓冲区中还没有数据），那么就直接返回一个EWOULDBLOCK错误，这种模式的一个问题就是你需要隔段时间去轮询一次，看操作系统内核缓冲区中是否有数据到来；一旦内核缓冲区准备好数据，那么调用开始阻塞，等待操作系统将内核缓冲区中的数据拷贝到用户空间中去，这段时间进程仍然是被阻塞住的，直到拷贝完成才能返回。
由此我们得出结论：阻塞和非阻塞I/O的区别在于是否需要等待操作系统将外部数据加载到内核缓冲区，即前面提到的第一次I/O执行。  ###3、I/O多路复用模型
I/O多路复用的基本原理是：将多个I/O的阻塞复用到对一个select的阻塞上，实现一个线程处理多个请求，它的核心在于多路复用器Selector，多个socket可以注册到一个Selector上，这个selector去轮询它所负责的socket，发现某一个socket的数据准备好了后就返回，然后去执行系统调用recvfrom。图中我们可以看出来，虽然I/O多路复用的函数也是阻塞的，但是其与以上两种还是有不同的，I/O多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用如recvfrom之上（所以两个系统调用，花费也更大，IO多路复用的性能是有可能比BIO还差的，但其优势在于处理多个连接，参考C10k问题）。
图中显示的系统调用是select，这就不得不引入到我们经典的几个系统调用（select、poll、epoll），这是需要单独的一篇文章来介绍三种调用的不同之处，当然它们的思想都是一致的。
深入理解select、epoll 当然最好还是看Linux内核书籍
注意：当selector轮询到某一个socket可读时，它返回，然后用户进程执行系统调用recvfrom，这个时候就又回到了我们的前两种I/O模型，此时，往往都采用的是NIO方式，因为尽管select返回了，告知用户进程某个socket可读，但并不告诉我们能读的数据有多少，甚至并不意味着我们接着调用recvfrom就能读到数据，所以I/O多路复用一般得搭配NIO。参考： &gt;为什么 IO 多路复用要搭配非阻塞 IO? &gt;使用epoll时需要将socket设为非阻塞吗？ 
###4、信号驱动模型 摘抄自《权威指南书》，首先开启套接口的信号驱动功能，并通过系统调用sigaction执行一个信号处理函数（此系统调用立即返回，用户进程继续工作）；当数据准备就绪时，就为该进程生成一个SIGIO信号，通过信号回调通知应用进程调用recvfrom接口来读取数据。 
###5、异步I/O模型 见识一下什么叫真正的异步I/O模型，直接告知内核开启某个操作，并让内核完成整个流程后（包括将数据准备好——拷贝到内核缓冲区，然后将数据从内和缓冲区复制到用户进程缓冲区）。信号驱动模型由内核通知我们什么时候可以开启一个I/O操作，而异步I/O模型直接告诉我们I/O操作已经完成了。 推荐书：Unix网络编程 
这就是传说中的五种Linux I/O模型，下一篇文章我们详细分析一下I/O多路复用模型，重点关注epoll。">
<meta property="og:url" content="https://monkback.github.io/posts/%E4%B8%80/" />
<meta property="og:type" content="website" />
<meta property="og:site_name" content="Records" />

  <meta name="twitter:title" content="Records" />
  <meta name="twitter:description" content="&emsp;&emsp;netty是一个用于客户端和服务器通信的高性能网络通信框架，涉及到跨机器之间的通信，必然离不开I/O，所以我们就从Java 的I/O演变之路开始讨论吧。
引出一个话题：什么是I/O，或者这么说，一次I/O究竟发生了哪些事情？我们从三个层面来理解一下I/O： 1. 从直观上来看：I/O是计算机和外部设备之间的数据流动过程。计算机即是我们平日里随处可见的一台机器，外部设备大体上 …">
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:card" content="summary" />
  <meta property="og:url" content="https://monkback.github.io/posts/%E4%B8%80/" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="Records" />

  <meta name="generator" content="Hugo 0.57.2" />
  <link rel="alternate" href="https://monkback.github.io/index.xml" type="application/rss+xml" title="Records"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/all.css" integrity="sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous"><link rel="stylesheet" href="https://monkback.github.io/css/main.css" /><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" /><link rel="stylesheet" href="https://monkback.github.io/css/syntax.css" /><link rel="stylesheet" href="https://monkback.github.io/css/codeblock.css" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css" integrity="sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css" integrity="sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R" crossorigin="anonymous">



  </head>
  <body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="https://monkback.github.io">Records</a>
    </div>

    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
        
          
            <li>
              <a title="Blog" href="/posts/">Blog</a>
            </li>
          
        
          
            <li>
              <a title="Categories" href="/categories/">Categories</a>
            </li>
          
        
          
            <li>
              <a title="Tags" href="/tags/">Tags</a>
            </li>
          
        
          
            <li>
              <a title="About" href="/about/">About</a>
            </li>
          
        

        

        
      </ul>
    </div>

    

  </div>
</nav>




    


<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>


  
  
  






  <div class="intro-header"></div>


    
<div class="container" role="main">
  <div class="row">
    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
      <article role="main" class="blog-post">
        

<p>&emsp;&emsp;netty是一个用于客户端和服务器通信的高性能网络通信框架，涉及到跨机器之间的通信，必然离不开I/O，所以我们就从Java 的I/O演变之路开始讨论吧。<br />
    引出一个话题：什么是I/O，或者这么说，一次I/O究竟发生了哪些事情？我们从三个层面来理解一下I/O：
    1. <strong>从直观上来看</strong>：I/O是计算机和外部设备之间的数据流动过程。计算机即是我们平日里随处可见的一台机器，外部设备大体上又包括输入设备和输出设备。比如，键盘、鼠标就属于输入设备；显示器属于输出设备。
    2. <strong>从计算机架构的层面来看</strong>：任何涉及到计算机核心（CPU和内存）与其他设备之间的数据转移就是I/O。本体就是计算机核心（CPU和内存）。例如从硬盘上读取数据到内存，是一次输入，将内存中的数据写入到硬盘就产生了输出。在计算机的世界里，这就是I/O的本质。
    3. <strong>从程序员编程的角度来看</strong>：此时，I/O的主体是我们编写的应用程序（即进程），需要注意的是，我们编写的应用程序其实并不存在实质的I/O过程，真正的I/O是操作系统的任务（用户态和内核态）。我们将应用程序代码的I/O细分为两个动作：I/O调用和I/O执行。I/O调用由应用程序（进程）发起的，而I/O执行是操作系统完成的（这就是<strong>系统调用</strong>），我们代码里写一个read()函数，实质上包含了我们程序发起的I/O调用，在看不见的地方，还有一次I/O执行（操作系统所完成的系统调用）。
       I/O调用的目的是将进程的内部数据迁移到外部即输出，或将外部数据迁移到进程内部即输入(<strong>应用程序是主体</strong>)。这里，外部数据指非进程空间数据，在编程时，通常讨论的场景是来自外部存储设备的数据，如硬盘、CD-ROM、以及需要socket通信传输的网络数据。
    我们来看一次典型的I/O输入会发生什么事情，以一个进程的输入类型的IO调用为例，它的工作内容如下：</p>

<ol>
<li>进程向操作系统请求外部数据——&gt;I/O调用</li>
<li>操作系统将外部数据加载到<strong>内核缓冲区</strong>———&gt;I/O执行</li>
<li>操作系统将数据从内核缓冲区<strong>拷贝到进程缓冲区</strong>———&gt;I/O执行</li>

<li><p>进程读取数据继续后面的工作<br />
接下来我们来对比两组常见的概念</p>

<h3 id="阻塞i-o和非阻塞i-o">阻塞I/O和非阻塞I/O</h3>

<p>阻塞和非阻塞强调的是进程对于操作系统IO是否处于就绪状态的处理方式。<br />
  上面已经说过，应用程序的IO实际是分为两个步骤，IO调用和IO执行。IO调用是由进程发起，IO执行是操作系统的工作。操作系统的IO情况决定了进程IO调用是否能够得到立即响应。如进程发起了读取数据的IO调用，操作系统需要将外部数据拷贝到进程缓冲区，在有数据拷贝到进程缓冲区前，进程缓冲区处于不可读状态，我们称之为操作系统IO未就绪。
  进程的IO调用是否能得到立即执行是需要操作系统IO处于就绪状态的，对于读取数据的操作，如果操作系统IO处于未就绪状态，当前进程或线程如果一直等待直到其就绪，该种IO方式为阻塞IO。如果进程或线程并不一直等待其就绪，而是可以做其他事情，这种方式为非阻塞IO。所以对于非阻塞IO，我们编程时需要经常去轮询就绪状态。</p>

<h3 id="同步i-o和异步i-o">同步I/O和异步I/O</h3>

<p>我们经常会谈及同步IO和异步IO。同步和异步描述的是针对当前执行线程、或进程而言，发起IO调用后，当前线程或进程是否挂起等待操作系统的IO执行完成。
  我们说一个IO执行是同步执行的，意思是程序发起IO调用，当前线程或进程需要等待操作系统完成IO工作并告知进程已经完成，线程或进程才能继续往下执行其他既定指令。
  如果说一个IO执行是异步的，意思是该动作是由当前线程或进程请求发起，且当前线程或进程不必等待操作系统IO的执行完毕，可直接继续往下执行其他既定指令。操作系统完成IO后，当前线程或进程会得到操作系统的通知。
  以一个读取数据的IO操作而言，在操作系统将外部数据写入进程缓冲区这个期间，进程或线程挂起等待操作系统IO执行完成的话，这种IO执行策略就为同步，如果进程或线程并不挂起而是继续工作，这种IO执行策略便为异步。</p>

<h4 id="总结-在io调用时-对待操作系统io就绪状态的不同方式-决定了其是阻塞或非阻塞模式-在io执行时-线程或进程是否挂起等待io执行决定了其是否为同步或异步io">总结：在IO调用时，对待操作系统IO就绪状态的不同方式，决定了其是阻塞或非阻塞模式；在IO执行时，线程或进程是否挂起等待IO执行决定了其是否为同步或异步IO。</h4></li>
</ol>

<p>在JDK引进NIO（Non-Blocking IO）之前，Java的I/O是阻塞式，都是面向流的，大体上可以分为两类：<br />
 - 基于字节流的InputStream和OutputStream<br />
 - 基于字符流的Reader和Writer<br />
  字符和字节之间的转换对应的就是编码和解码。在这个时期Java的IO是同步阻塞的（attention：同步和阻塞不是一个概念，他们是不同维度的），且只有输出流和输入流，没有channe、buffer等，效率很低。
<a href="https://book.douban.com/subject/1433583/" title="Java NIO">Java NIO中文版</a>这本书剖析了Java NIO，清晰易懂，推荐阅读。<br />
这里，我们借用权威书《UNIX 网络编程：卷一》中的内容，来讨论Linux下的5种I/O模型。</p>

<p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所有等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用程序缓冲区。 好，下面我们以阻塞套接字的recvfrom的的调用图来说明。</p>

<p>###1、阻塞I/O模型<br />
   如图所示，这是最常用的I/O模型，缺省情况下所有的文件操作都是阻塞的，事实上，网络I/O也是文件I/O的一种（SocketOutputStream是FileOutputStream的子类）。在进程空间发起recvfrom调用（<strong>一次I/O调用</strong>）；此时转到操作系统内核，操作系统内核将数据加载到内核缓冲区（<strong>一次I/O执行</strong>），这段时间应用进程阻塞住，等待数据准备好；然后由操作系统将数据从内核缓冲区拷贝至用户进程缓冲区（<strong>I/O执行</strong>），这段时间应用进程仍然处于阻塞状态，等待数据拷贝完成；一旦拷贝完成，操作系统内核就告知用户进程，调用成功返回。由此图我们可以得知，阻塞I/O模型在两个时间段都是被阻塞的。
<a href="https://imgchr.com/i/AJAlVS"><img src="https://s2.ax1x.com/2019/03/23/AJAlVS.png" alt="AJAlVS.png" /></a>
###2、非阻塞I/O模型<br />
   还是截了一张书中的图，可以看到，应用进程在发起recvfrom调用的时候，如果发现操作系统内核还没有把数据准备好（即操作系统内核缓冲区中还没有数据），那么就直接返回一个EWOULDBLOCK错误，这种模式的一个问题就是你需要隔段时间去轮询一次，看操作系统内核缓冲区中是否有数据到来；一旦内核缓冲区准备好数据，那么调用开始阻塞，等待操作系统将内核缓冲区中的数据拷贝到用户空间中去，这段时间进程仍然是被阻塞住的，直到拷贝完成才能返回。<br />
   <strong>由此我们得出结论：阻塞和非阻塞I/O的区别在于是否需要等待操作系统将外部数据加载到内核缓冲区</strong>，即前面提到的第一次I/O执行。
<a href="https://imgchr.com/i/AtJa11"><img src="https://s2.ax1x.com/2019/03/25/AtJa11.png" alt="AtJa11.png" /></a>
###3、I/O多路复用模型<br />
   I/O多路复用的基本原理是：将多个I/O的阻塞复用到对一个select的阻塞上，实现一个线程处理多个请求，它的核心在于多路复用器Selector，多个socket可以注册到一个Selector上，这个selector去轮询它所负责的socket，发现某一个socket的数据准备好了后就返回，然后去执行系统调用recvfrom。图中我们可以看出来，虽然I/O多路复用的函数也是阻塞的，但是其与以上两种还是有不同的，I/O多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用如recvfrom之上（所以两个系统调用，花费也更大，IO多路复用的性能是有可能比BIO还差的，但其优势在于处理多个连接，参考C10k问题）。<br />
   图中显示的系统调用是select，这就不得不引入到我们经典的几个系统调用（select、poll、epoll），这是需要单独的一篇文章来介绍三种调用的不同之处，当然它们的思想都是一致的。<br />
<a href="https://wyj.shiwuliang.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SELECT%E3%80%81POLL%E5%92%8CEPOLL%20.html" title="详解select、epoll">深入理解select、epoll</a>   当然最好还是看Linux内核书籍<br />
   注意：当selector轮询到某一个socket可读时，它返回，然后用户进程执行系统调用recvfrom，<strong>这个时候就又回到了我们的前两种I/O模型</strong>，此时，往往都采用的是NIO方式，因为尽管select返回了，告知用户进程某个socket可读，但并不告诉我们能读的数据有多少，<strong>甚至并不意味着我们接着调用recvfrom就能读到数据</strong>，所以I/O多路复用一般得搭配NIO。参考：
&gt;<a href="https://www.zhihu.com/question/37271342">为什么 IO 多路复用要搭配非阻塞 IO?</a>
&gt;<a href="https://www.zhihu.com/question/23614342">使用epoll时需要将socket设为非阻塞吗？</a>
<a href="https://imgchr.com/i/AttrJH"><img src="https://s2.ax1x.com/2019/03/25/AttrJH.png" alt="AttrJH.png" /></a></p>

<p>###4、信号驱动模型
摘抄自《权威指南书》，首先开启套接口的信号驱动功能，并通过系统调用sigaction执行一个信号处理函数（此系统调用立即返回，用户进程继续工作）；当数据准备就绪时，就为该进程生成一个SIGIO信号，通过信号回调通知应用进程调用recvfrom接口来读取数据。
<a href="https://imgchr.com/i/AwYmfU"><img src="https://s2.ax1x.com/2019/03/28/AwYmfU.png" alt="AwYmfU.png" /></a></p>

<p>###5、异步I/O模型
见识一下什么叫真正的异步I/O模型，直接告知内核开启某个操作，并让内核完成整个流程后（包括将数据准备好——拷贝到内核缓冲区，然后将数据从内和缓冲区复制到用户进程缓冲区）。信号驱动模型由内核通知我们什么时候可以开启一个I/O操作，而异步I/O模型直接告诉我们I/O操作已经完成了。
推荐书：<a href="https://book.douban.com/subject/1500149/" title="Unix网络编程">Unix网络编程</a>
<a href="https://imgchr.com/i/AwYa1e"><img src="https://s2.ax1x.com/2019/03/28/AwYa1e.png" alt="AwYa1e.png" /></a></p>

<p>这就是传说中的五种Linux I/O模型，下一篇文章我们详细分析一下I/O多路复用模型，重点关注epoll。</p>


        

        

        
      </article>

      
        <ul class="pager blog-pager">
          
            <li class="previous">
              <a href="https://monkback.github.io/posts/%E4%BA%8C/" data-toggle="tooltip" data-placement="top" title="">&larr; Previous Post</a>
            </li>
          
          
        </ul>
      


      

    </div>
  </div>
</div>

    <footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">
          
          
        </ul>
        <p class="credits copyright text-muted">
          

          &nbsp;&bull;&nbsp;&copy;
          
            2017 - 2019
          

          
            &nbsp;&bull;&nbsp;
            <a href="https://monkback.github.io">Records</a>
          
        </p>
        
        <p class="credits theme-by text-muted">
          <a href="http://gohugo.io">Hugo v0.57.2</a> powered &nbsp;&bull;&nbsp; Theme by <a href="http://deanattali.com/beautiful-jekyll/">Beautiful Jekyll</a> adapted to <a href="https://github.com/halogenica/beautifulhugo">Beautiful Hugo</a>
          
        </p>
      </div>
    </div>
  </div>
</footer><script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.js" integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/contrib/auto-render.min.js" integrity="sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe" crossorigin="anonymous"></script>
<script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

<script src="https://monkback.github.io/js/main.js"></script><script> renderMathInElement(document.body); </script><script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js" integrity="sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js" integrity="sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q" crossorigin="anonymous"></script><script src="https://monkback.github.io/js/load-photoswipe.js"></script>









  </body>
</html>

