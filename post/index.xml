<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Records</title>
    <link>https://monkback.github.io/post/</link>
    <description>Recent content in Posts on Records</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 10 Aug 2020 15:24:03 +0800</lastBuildDate>
    
	<atom:link href="https://monkback.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Leetcode—栈相关</title>
      <link>https://monkback.github.io/post/algorithm/leetcode/leetcode-stack/</link>
      <pubDate>Mon, 10 Aug 2020 15:24:03 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/algorithm/leetcode/leetcode-stack/</guid>
      <description>这篇文章是LeetCode上栈相关的题目，只涉及思路和方法，没有完整代码。 20、给定一个只包括 &amp;lsquo;(&amp;lsquo;，&amp;rsquo;</description>
    </item>
    
    <item>
      <title>Leetcode—排序相关题目</title>
      <link>https://monkback.github.io/post/algorithm/leetcode/leetcode-sort/</link>
      <pubDate>Wed, 29 Jul 2020 17:08:10 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/algorithm/leetcode/leetcode-sort/</guid>
      <description>最近打算按照LeetCode的标签来做一些题目，有些题目可能属于多个标签，比如一个题目既可能是数组相关，又可能是双指针相关，我想先打算做刷前</description>
    </item>
    
    <item>
      <title>字符串匹配算法</title>
      <link>https://monkback.github.io/post/algorithm/string/</link>
      <pubDate>Thu, 09 Jul 2020 15:18:18 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/algorithm/string/</guid>
      <description>字符串匹配也是一个比较常见的功能了，本质上，就是从一个字符串中查找另一个字符串，传说中的KMP 算法就是讲这个的，在深入了解复杂的匹配算法之前</description>
    </item>
    
    <item>
      <title>深度优先搜索和广度优先搜索</title>
      <link>https://monkback.github.io/post/algorithm/bfs-dfs/</link>
      <pubDate>Mon, 06 Jul 2020 16:52:23 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/algorithm/bfs-dfs/</guid>
      <description>在树的那一章节，提到过深度优先和广度优先的思想，具体用在一棵树的遍历上，前面写的前序、中序和后序都是深度优先遍历，而层次 遍历利用一个队列，来</description>
    </item>
    
    <item>
      <title>深入理解Java虚拟机</title>
      <link>https://monkback.github.io/post/jvm/jvm/</link>
      <pubDate>Thu, 02 Jul 2020 17:07:54 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/jvm/jvm/</guid>
      <description>之前也很粗略的看过一遍《深入理解Java虚拟机》一书，但是有很多地方都没有看懂，导致现在忘 了很多了已经，现在开始再重新看一遍，这次看的是第三</description>
    </item>
    
    <item>
      <title>堆和堆排序</title>
      <link>https://monkback.github.io/post/algorithm/heap/</link>
      <pubDate>Wed, 01 Jul 2020 09:56:33 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/algorithm/heap/</guid>
      <description>堆是一种特殊的树，或者说，一种特殊的完全二叉树，一棵树只要满足下面两个条件， 那么它就是一个堆。 1） 它是一棵完全二叉树，即叶子节点都在最下面两</description>
    </item>
    
    <item>
      <title>Netty实战读书笔记</title>
      <link>https://monkback.github.io/post/net/netty/nettyinaction/</link>
      <pubDate>Wed, 17 Jun 2020 23:06:25 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/net/netty/nettyinaction/</guid>
      <description>2020-6-17，开始重读《netty实战》一书 这本书和前面那本《netty权威指南》不太一样的是，这本书开始先介绍netty中的各类组件</description>
    </item>
    
    <item>
      <title>二叉树</title>
      <link>https://monkback.github.io/post/algorithm/tree/</link>
      <pubDate>Thu, 04 Jun 2020 15:49:41 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/algorithm/tree/</guid>
      <description>好长一段时间没有看《数据结构与算法之美》系列了，现在重归树这一章节，这里的内容会比较多，也不会太容易理解，尤其后面涉及到 红黑树的地方。事实上</description>
    </item>
    
    <item>
      <title>Netty权威指南读书笔记</title>
      <link>https://monkback.github.io/post/net/netty/nettyguide/</link>
      <pubDate>Thu, 04 Jun 2020 14:03:53 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/net/netty/nettyguide/</guid>
      <description>2020-6-4，开始重读李林峰的《netty权威指南》 一、IO模型 Linux内核将所有的外部设备都看作一个文件，对一个文件的读写操作会调用</description>
    </item>
    
    <item>
      <title>数据结构之散列表</title>
      <link>https://monkback.github.io/post/algorithm/hashtable/</link>
      <pubDate>Sun, 31 May 2020 21:52:27 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/algorithm/hashtable/</guid>
      <description>哈希表，内部是依赖着数组来存储元素的，因为数组可以支持随机访问。看到这一章节时，我想起来之前看《代码大全》时， 里面提到的一种思维：数组本质上</description>
    </item>
    
    <item>
      <title>BinarySearch及其变种</title>
      <link>https://monkback.github.io/post/algorithm/binarysearch/</link>
      <pubDate>Wed, 27 May 2020 23:07:37 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/algorithm/binarysearch/</guid>
      <description>终于看到了王争的二分查找章节了，这其实是我一直以来的一个痛点，因为二分查找听起来简单，但它有各种变种，记得我之前找工作的时候 ，就没有掌握到二</description>
    </item>
    
    <item>
      <title>分布式锁的一次问题排查</title>
      <link>https://monkback.github.io/post/work/cyclicbarrier/</link>
      <pubDate>Wed, 27 May 2020 17:48:29 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/work/cyclicbarrier/</guid>
      <description>这篇文章来源于工作中发现的一个项目bug。 1、项目背景： 这是一个rpc服务，维护的是公司所有用户的基本信息，包括用户注册、修改、注销以及查询</description>
    </item>
    
    <item>
      <title>Linux系统下的CPU核数问题</title>
      <link>https://monkback.github.io/post/linux/cpu/</link>
      <pubDate>Fri, 22 May 2020 16:34:20 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/linux/cpu/</guid>
      <description>这篇文章源于我们在项目中使用线程池时，但是不会评估线程池的一些初始参数应该怎么设置。我们的服务是部署在公司的私有云平台 上，一共申请了4个节点</description>
    </item>
    
    <item>
      <title>Java中的线程池</title>
      <link>https://monkback.github.io/post/juc/threadpool/</link>
      <pubDate>Mon, 18 May 2020 15:51:42 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/juc/threadpool/</guid>
      <description>ThreadPoolExecutor继承了AbstractExecutorService类，并提供了四个构造函数，实际上，其中的三个都是调用</description>
    </item>
    
    <item>
      <title>常用排序算法</title>
      <link>https://monkback.github.io/post/algorithm/sortalgorithm/</link>
      <pubDate>Fri, 15 May 2020 10:57:50 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/algorithm/sortalgorithm/</guid>
      <description>一 冒泡排序 通过n次冒泡的过程，让每个元素放到合适的位置。第一次冒泡，让将最大的元素放在最后一个位置；第二次冒泡，让第二大的元素放在倒数第二个</description>
    </item>
    
    <item>
      <title>AbstractQueuedSynchronizer理解</title>
      <link>https://monkback.github.io/post/juc/abstractqueuedsynchronizer/</link>
      <pubDate>Wed, 13 May 2020 10:28:43 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/juc/abstractqueuedsynchronizer/</guid>
      <description>队列同步器AbstractQueuedSynchronizer是用来构建锁和其他同步工具的关键，我们熟知的ReentrantLock(有公平</description>
    </item>
    
    <item>
      <title>Java内存模型</title>
      <link>https://monkback.github.io/post/jvm/jmm/</link>
      <pubDate>Mon, 11 May 2020 11:43:22 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/jvm/jmm/</guid>
      <description>在看《Java并发编程的艺术》一书时，涉及到了Java内存模型，也就是JVM中各个区域的内存分布，每一块区域都存储了哪些内容，这篇文章主要就</description>
    </item>
    
    <item>
      <title>读方腾飞的《Java 并发编程的艺术》</title>
      <link>https://monkback.github.io/post/juc/theartofconcurrencyprogramming/</link>
      <pubDate>Wed, 06 May 2020 18:08:29 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/juc/theartofconcurrencyprogramming/</guid>
      <description>之前粗略的看过一次这本书，但是那时候基础知识并不好，有很多地方都看得云里雾里的，这次再尝试读一遍。 第一章里提到，我们都知道如果用多线程就会导</description>
    </item>
    
    <item>
      <title>Array LinkedList</title>
      <link>https://monkback.github.io/post/algorithm/array-linkedlist/</link>
      <pubDate>Tue, 05 May 2020 21:51:06 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/algorithm/array-linkedlist/</guid>
      <description>这篇是数组和链表的几个题目，出自数据结构与算法之美专栏。 一、实现一个支持动态扩容的数组。这个</description>
    </item>
    
    <item>
      <title>读数据结构与算法之美</title>
      <link>https://monkback.github.io/post/algorithm/thebeautyofdatastructureandalgorithm/</link>
      <pubDate>Tue, 28 Apr 2020 10:09:44 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/algorithm/thebeautyofdatastructureandalgorithm/</guid>
      <description>2020-4-28，今天开始阅读数据结构与算法之美系列的文章了，看了下一共是56个小节，计划每天完成一个小节的内容，那么预期在两个月读完（实</description>
    </item>
    
    <item>
      <title>ThreadSafeCollection</title>
      <link>https://monkback.github.io/post/juc/threadsafecollection/</link>
      <pubDate>Fri, 24 Apr 2020 17:17:50 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/juc/threadsafecollection/</guid>
      <description>我们知道concurrent包里面引入了一些线程安全的集合，但是除了ConcurrentHashMap，其他都没用过，这些线程安全的集合 和我</description>
    </item>
    
    <item>
      <title>对象的初始化安全—论static和final</title>
      <link>https://monkback.github.io/post/juc/object/</link>
      <pubDate>Sun, 19 Apr 2020 18:13:56 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/juc/object/</guid>
      <description>我们知道，静态变量只会被初始化一次。事实上，一个类被JVM加载以后，该类的所有静态变量的值都是默认值(引用变量就是null ，boolean变</description>
    </item>
    
    <item>
      <title>单例模式的几种实现方式</title>
      <link>https://monkback.github.io/post/juc/singleton/</link>
      <pubDate>Sun, 19 Apr 2020 13:48:54 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/juc/singleton/</guid>
      <description>先看一下传统的double-check模式，代码如下： public class Singleton { private static volatile Singleton instance = null; private Singleton() {} public static Singleton getInstance() { if (instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } } return instance; } }</description>
    </item>
    
    <item>
      <title>Utf 8</title>
      <link>https://monkback.github.io/post/work/utf-8/</link>
      <pubDate>Tue, 14 Apr 2020 17:29:06 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/work/utf-8/</guid>
      <description>一个坑点，暂时作为记录： 在本地编辑好的文本文件，比如用notepad或者其他编辑器，或者你自己写一个Java、Python程序处理文本文件，</description>
    </item>
    
    <item>
      <title>Thread类</title>
      <link>https://monkback.github.io/post/juc/thread/</link>
      <pubDate>Tue, 14 Apr 2020 15:44:55 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/juc/thread/</guid>
      <description>最近在看一本比较基础的书《Java 多线程编程核心技术》，发现里面有一个关于Thread类的知识点，是我以前没有注意过的，比较有意思， 记录如下</description>
    </item>
    
    <item>
      <title>Spring Bean LifeCycle</title>
      <link>https://monkback.github.io/post/spring/spring-bean-lifecycle/</link>
      <pubDate>Wed, 25 Mar 2020 16:58:14 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/spring/spring-bean-lifecycle/</guid>
      <description>这是回顾Spring系列书籍的第二篇文章，主要分析Spring容器中Bean的生命周期，这里的Spring容器主要指BeanFactory，</description>
    </item>
    
    <item>
      <title>Spring容器与web容器</title>
      <link>https://monkback.github.io/post/spring/spring%E5%AE%B9%E5%99%A8%E4%B8%8Eweb%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Tue, 17 Mar 2020 20:24:24 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/spring/spring%E5%AE%B9%E5%99%A8%E4%B8%8Eweb%E5%AE%B9%E5%99%A8/</guid>
      <description>最近回顾了一下去年看过的Spring相关的书籍，从《精通Spring 4.x 企业应用开发实战》这本书开始的，一上来我就又忘记了之前看过 的一个知识点</description>
    </item>
    
    <item>
      <title>2020年看书规划</title>
      <link>https://monkback.github.io/post/work/schedule/</link>
      <pubDate>Sat, 29 Feb 2020 20:22:48 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/work/schedule/</guid>
      <description>拒绝浪费时间，重拾看书规划，这篇文章会持续更新记录。 2020年3月开始，先花两周的时间复习一下Spring相关内容，因为之前已经花很多时间看</description>
    </item>
    
    <item>
      <title>链表相关算法</title>
      <link>https://monkback.github.io/post/algorithm/linkedlist/</link>
      <pubDate>Tue, 14 Jan 2020 10:52:08 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/algorithm/linkedlist/</guid>
      <description>自己算法上的知识一直都很薄弱，好些题目都是靠之前的死记硬背下来的，过段时间就忘记解法了。所以最近在看极客时间上的一个专栏《数据结构与算法之美</description>
    </item>
    
    <item>
      <title>Redis 分布式锁的可重入</title>
      <link>https://monkback.github.io/post/redis/redis-reentrant-lock/</link>
      <pubDate>Wed, 25 Dec 2019 15:38:33 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/redis/redis-reentrant-lock/</guid>
      <description>最近在看《Redis 深度历险》这本书，我们都知道Redis用来实现分布式锁是一种常用的技术方案，本质上 就是用命令setnx ex来占据一个坑位</description>
    </item>
    
    <item>
      <title>遇到的FastJson的一个问题</title>
      <link>https://monkback.github.io/post/work/fastjson/</link>
      <pubDate>Thu, 21 Nov 2019 20:22:13 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/work/fastjson/</guid>
      <description>最近在项目中遇到了一个问题，在打印日志的时候，使用了一个统一封装的框架，将一个对象A打出来。结果确发现在日志里打出来的这个对象有一些本来不应</description>
    </item>
    
    <item>
      <title>Spring 4.x 阅读笔记(数据访问篇)</title>
      <link>https://monkback.github.io/post/spring/springdao/</link>
      <pubDate>Sun, 10 Nov 2019 17:04:12 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/spring/springdao/</guid>
      <description>Spring事务管理方面，没有细看，欠缺。</description>
    </item>
    
    <item>
      <title>560 Subarray Sum Equals K</title>
      <link>https://monkback.github.io/post/algorithm/leetcode/560-subarray-sum-equals-k/</link>
      <pubDate>Fri, 01 Nov 2019 18:12:07 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/algorithm/leetcode/560-subarray-sum-equals-k/</guid>
      <description>560-Subarray Sum Equals K 题目：Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k. Example 1: Input:nums = [1,1,1], k = 2 Output: 2 The length of the array is in range [1, 20,000]. The range of numbers in the array is [-1000, 1000] and the range of the</description>
    </item>
    
    <item>
      <title>一次关于CompletionService的使用</title>
      <link>https://monkback.github.io/post/work/completionservice/</link>
      <pubDate>Thu, 31 Oct 2019 20:03:31 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/work/completionservice/</guid>
      <description>背景 最近在项目里需要实现这样一个接口：从多个数据源分别查询不同的数据，再将所有的结果组装在一起，返回最终结果。本身上没有什么难点，只是这一段</description>
    </item>
    
    <item>
      <title>621 Task Cheduler</title>
      <link>https://monkback.github.io/post/algorithm/leetcode/621-task-cheduler/</link>
      <pubDate>Sat, 26 Oct 2019 17:19:45 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/algorithm/leetcode/621-task-cheduler/</guid>
      <description>621-Task Scheduler 题目：Given a char array representing tasks CPU need to do. It contains capital letters A to Z where different letters represent different tasks. Tasks could be done without original order.Each task could be done in one interval. For each interval, CPU could finish one task or just be idle. However, there is a non-negative cooling interval n that means between two</description>
    </item>
    
    <item>
      <title>647 Palindromic Substrings</title>
      <link>https://monkback.github.io/post/algorithm/leetcode/647-palindromic-substrings/</link>
      <pubDate>Thu, 24 Oct 2019 17:35:13 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/algorithm/leetcode/647-palindromic-substrings/</guid>
      <description>647-Palindromic Substrings 题目：Given a string, your task is to count how many palindromic substrings in this string. The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters. Example 1: Input: &amp;ldquo;abc&amp;rdquo; Output: 3 Explanation: Three palindromic strings: &amp;ldquo;a&amp;rdquo;, &amp;ldquo;b&amp;rdquo;, &amp;ldquo;c&amp;rdquo;. Example 2: Input: &amp;ldquo;aaa&amp;rdquo; Output: 6 Explanation: Six palindromic strings: &amp;ldquo;a&amp;rdquo;, &amp;ldquo;a&amp;rdquo;, &amp;ldquo;a&amp;rdquo;,</description>
    </item>
    
    <item>
      <title>739 Daily Temperatures</title>
      <link>https://monkback.github.io/post/algorithm/leetcode/739-dailytemperatures/</link>
      <pubDate>Tue, 22 Oct 2019 20:19:40 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/algorithm/leetcode/739-dailytemperatures/</guid>
      <description>739-dailyTemperatures 题目：Given a list of daily temperatures T, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead. For example, given the list of temperatures T = [73, 74, 75, 71, 69, 72, 76,</description>
    </item>
    
    <item>
      <title>对paxos的一些理解</title>
      <link>https://monkback.github.io/post/work/paxos/</link>
      <pubDate>Mon, 14 Oct 2019 10:38:40 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/work/paxos/</guid>
      <description>由于最近需要在组内做一个分享，而且Spring那块我还没搞完，就打算选paxos的一些问题来梳理理解一下，这也就是技术分享的最大好处，需要你</description>
    </item>
    
    <item>
      <title>Spring 4.x 阅读笔记(五)</title>
      <link>https://monkback.github.io/post/spring/spring4read4/</link>
      <pubDate>Thu, 03 Oct 2019 13:22:59 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/spring/spring4read4/</guid>
      <description>第八章 基于AspectJ和Schema的AOP 基于注解的方式比上一章继承扩展各种类和接口要方便多了，首推的是这种方式。</description>
    </item>
    
    <item>
      <title>Spring 4.x 阅读笔记(四)</title>
      <link>https://monkback.github.io/post/spring/spring4read3/</link>
      <pubDate>Thu, 03 Oct 2019 13:22:59 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/spring/spring4read3/</guid>
      <description>第七章 Spring AOP基础 Aspect Oriented Programming，我们无法通过抽象父类的方式来消除一些重复的横切代码，AOP是通过横向抽取机制来进行抽象的。AO</description>
    </item>
    
    <item>
      <title>Spring 4.x 阅读笔记(三)</title>
      <link>https://monkback.github.io/post/spring/spring4read2/</link>
      <pubDate>Thu, 26 Sep 2019 23:15:06 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/spring/spring4read2/</guid>
      <description>第五章 在IOC容器中装配Bean Spring启动时读取应用程序提供的Bean配置信息，并在Spring容器中生成一份相应的Bean配置注册表</description>
    </item>
    
    <item>
      <title>Spring 4.x 阅读笔记(二)</title>
      <link>https://monkback.github.io/post/spring/spring4read1/</link>
      <pubDate>Sun, 22 Sep 2019 17:04:23 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/spring/spring4read1/</guid>
      <description>第四章 IOC Inverse Of Control：某一接口具体实现类的选择控制权从 调用类 中移除，转交给第三方，即Spring容器(利用Bean配置来控制) 这其实是</description>
    </item>
    
    <item>
      <title>Spring 4.x 阅读笔记(一)</title>
      <link>https://monkback.github.io/post/spring/spring4read/</link>
      <pubDate>Mon, 16 Sep 2019 16:35:04 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/spring/spring4read/</guid>
      <description>第一章 概述 提起Spring这个框架，我们都会说到Inverse of Control和Aspect Oriented Programming，我所理解的这是两种思维</description>
    </item>
    
    <item>
      <title>NIO-1</title>
      <link>https://monkback.github.io/post/net/nio1/</link>
      <pubDate>Tue, 03 Sep 2019 18:10:06 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/net/nio1/</guid>
      <description>netty是一个用于客户端和服务器通信的高性能网络通信框架，涉及到跨机器之间的通信，必然离不开I/O，所以我们就从Java 的I/O演变之路开</description>
    </item>
    
    <item>
      <title>NIO-2</title>
      <link>https://monkback.github.io/post/net/nio2/</link>
      <pubDate>Tue, 03 Sep 2019 18:10:06 +0800</pubDate>
      
      <guid>https://monkback.github.io/post/net/nio2/</guid>
      <description>###传统的BIO### 我们先使用一个传统的client/server模式来编写了一段两个进程之间通信的代码。ServerSocke负责绑定</description>
    </item>
    
  </channel>
</rss>