<!DOCTYPE html>
<html lang="zh-cn" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Linux高性能服务器编程 - Records</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">


  <meta name="description" content="总览 最近发现了一本不错的书，叫《Linux高性能服务器编程》，我从豆瓣阅读上买了一本电子书，大体初略的看了一遍，从TCP/IP协议，讲到so" />







<meta name="generator" content="Hugo 0.57.2" />


<link rel="canonical" href="https://monkback.github.io/post/linux/linuxhighperformanceserverprogram/" />



<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.af20b78e95c84de86b00a0242a4a77bd2601700e1b250edf27537d957ac0041d.css" integrity="sha256-ryC3jpXITehrAKAkKkp3vSYBcA4bJQ7fJ1N9lXrABB0=" media="screen" crossorigin="anonymous">





<meta property="og:title" content="Linux高性能服务器编程" />
<meta property="og:description" content="总览 最近发现了一本不错的书，叫《Linux高性能服务器编程》，我从豆瓣阅读上买了一本电子书，大体初略的看了一遍，从TCP/IP协议，讲到so" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://monkback.github.io/post/linux/linuxhighperformanceserverprogram/" />
<meta property="article:published_time" content="2020-10-11T17:16:40+08:00" />
<meta property="article:modified_time" content="2020-10-11T17:16:40+08:00" />
<meta itemprop="name" content="Linux高性能服务器编程">
<meta itemprop="description" content="总览 最近发现了一本不错的书，叫《Linux高性能服务器编程》，我从豆瓣阅读上买了一本电子书，大体初略的看了一遍，从TCP/IP协议，讲到so">


<meta itemprop="datePublished" content="2020-10-11T17:16:40&#43;08:00" />
<meta itemprop="dateModified" content="2020-10-11T17:16:40&#43;08:00" />
<meta itemprop="wordCount" content="15622">



<meta itemprop="keywords" content="Linux,网络编程," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Linux高性能服务器编程"/>
<meta name="twitter:description" content="总览 最近发现了一本不错的书，叫《Linux高性能服务器编程》，我从豆瓣阅读上买了一本电子书，大体初略的看了一遍，从TCP/IP协议，讲到so"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->




</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Records</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://monkback.github.io/post/">Blog</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://monkback.github.io/categories/">Categories</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://monkback.github.io/tags/">Tags</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://monkback.github.io/about/">About</a>
          
        
      </li>
    

    
  </ul>
</nav>


  

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      Records
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://monkback.github.io/post/">Blog</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://monkback.github.io/categories/">Categories</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://monkback.github.io/tags/">Tags</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://monkback.github.io/about/">About</a>
          

        

      </li>
    

    
    

    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">Linux高性能服务器编程</h1>
      
      <div class="post-meta">
        <time datetime="2020-10-11" class="post-time">
          2020-10-11
        </time>
        
        

        
        

        
        
      </div>
    </header>

    
    

    
    <div class="post-content">
      

<h1 id="总览">总览</h1>

<p>　　最近发现了一本不错的书，叫《Linux高性能服务器编程》，我从豆瓣阅读上买了一本电子书，大体初略的看了一遍，从TCP/IP协议，讲到socket基础，再到服务器网络编程的几种模式，最后聊到了libevent
（一种高性能的服务端网络编程框架，c语言实现），等同于Java中的netty，我打算以这本书为核心，再次学习一遍网络知识，TCP的核心内容需要学习《TCP/IP详解-协议》一书中的TCP相关章节，
可以结合《图解TCP_IP》一书（非常浅显），从常规的三次握手，到复杂一点的拥塞控制，再到socket内核相关的参数，结合着陶辉（就是写Nginx书籍的）的博客，结合收藏过的所有博客文章（包括刘超的趣谈网络协议
中的TCP部分），必须彻底搞懂。</p>

<p>　　上面的内容结束以后，自然的过度到epoll、netty，争取记下来netty的相关知识点，最好是能够对照libevent相关的文章，学习一下其源码，最高的要求是，学习陈硕的那本muduo库的网络编程书籍。</p>

<h3 id="一-tcp-ip协议族">一、TCP/IP协议族</h3>

<p>　　TCP/IP协议族是一个四层的协议系统，分别是数据链路层、网络层、传输层和应用层，也有一种说法是七层（还有物理层、会话层和表示层）。这里我们通常按照
下面四层协议来解读</p>

<h5 id="1-数据链路层">1、数据链路层</h5>

<p>　　数据链路层实现的是网卡接口的网络驱动程序，处理数据在物理媒介（比如以太网、令牌环等）上的传输。这一层最常用的协议是ARP（Address Resolve Protocol
，地址解析协议）和RARP（Reverse Address Resolve Protocol， 逆地址解析协议），它们实现的是IP地址和机器物理地址（通常是MAC地址）之间的互相转换。</p>

<p>　　网络层使用IP地址寻址一台机器，数据链路层使用物理地址寻址一台机器，因此网络层在将数据包传递给数据链路层的时候，需要利用ARP协议将目标机器的IP地址转换
为物理地址。</p>

<h5 id="2-网络层">2、网络层</h5>

<p>　　网络上通信的两台主机一般都不是直接相连的，而是通过多个中间节点（路由器）连接的，网络层就是找到这些中间的节点，以确定两台主机的通信路径。同时网络层对
上层协议隐藏了这些网络拓扑细则，使得传输层和更上层的应用层看来，通信的双方是直接相连的。</p>

<p>　　网络层最核心的协议是IP协议（Internet Protocol），IP协议根据数据包的目的IP地址来决定如何投递这个数据包，如果不能直接发送给目的主机，就利用某些
算法策略为其寻找一个合适的下一跳路由器，将数据包交给该路由器来转发，重复这个过程直到数据包到达目的主机或者由于发送失败被丢弃。</p>

<p>　　网络层还有一个ICMP协议（Internet Control Message Protocol），主要用于网络检测，这里有一个比较有意思的点是，应用层直接ping某个IP地址时，是
直接使用网络层的ICMP协议，这里中间是不经过传输层的，也就是没有TCP/UDP的参与。</p>

<h5 id="3-传输层">3、传输层</h5>

<p>　　传输层为两台主机的应用程序提供端到端的通信，网络层是使用的逐跳通信方式，传输层只关注通信的起始端和终点端，并不在乎数据包的中间过程。这里其实又是一个
封装的思想。</p>

<p>　　传输层的协议主要有三个：TCP（Transmission Control Protocol，传输控制协议）、UDP（User Datagram Protocol， 用户数据报协议）、SCTP（
Stream Control Transmission Protocol， 流控制传输协议），其中SCTP是一种比较新的传输层协议，是为了在因特网上传输电话信号而设计的，可以先忽略。</p>

<ul>
<li><p><strong>TCP</strong>：TCP为应用层提供可靠的、面向连接的、基于流的服务。TCP使用数据确认和超时重传机制来保证数据包正确的发送到接收端，这是可靠；使用TCP协议进行通
信的双方必须先建立TCP连接，并且在内核中为这个连接维护一些数据结构（连接的状态，读写缓冲区，一些定时器等），通信结束时，双方必须关闭连接以释放这些内核数据
结构，这是面向连接；基于流的数据没有边界限制，它源源不断的从一端流向另一端，发送端可以逐个字节的向数据流中写入数据，接收端也可以逐个字节的从流中读取数据。</p></li>

<li><p><strong>UDP</strong>：UDP提供的服务不可靠、无连接，面向数据报。不可靠意味着UDP协议并不保证数据从发送端正确的传输到目的端，如果数据中途丢失，UDP协议只是简单的
通知上层应用程序发送失败，因此使用UDP协议的应用程序往往需要自己处理数据确认、超时重传等逻辑。UDP协议通信的双方并不需要保持一个连接，因此应用程序每次发送
的时候都需要明确指定接收端的地址；每个UDP数据报都有一个长度，接收端必须以该长度为最小单位将其内容一次读取出。</p></li>
</ul>

<h5 id="4-应用层">4、应用层</h5>

<p>　　应用层负责处理应用程序的逻辑，在用户空间实现（其实也可以在内核空间）；数据链路层、网络层和传输层负责处理网络通信细则，必须高效稳定，因此在内核空间实现。
常用的应用层协议包括：HTTP、DNS、telnet、OSPF。</p>

<p>　　应用层协议通常使用传输层协议提供的服务，比如DNS就使用的UDP，HTTP常使用TCP，也可以跳过传输层，直接使用网络层提供的服务，比如ping程序和OSPF协议。</p>

<h5 id="封装">封装</h5>

<p>　　每层协议都将在上层数据的基础上加上自己的头部信息（有时还包括尾部信息，以太网就还需要加尾部），以实现该层的功能，这个过程就称为<strong>封装</strong>。</p>

<p>　　经过TCP封装后的数据就称为TCP报文段，因为TCP协议为通信的双方在内核维护了一个连接，并在内核存储了一些当前这个连接相关的数据；这部分数据中的TCP头部信息和<strong>TCP内核缓冲区（发送缓冲区或者接收缓冲区）</strong>
的数据一起构成了一个<strong>TCP报文段</strong>。发送端应用程序调用send（或者write）函数向一个TCP连接写入数据时，内核中的TCP模块首先把数据复制到该连接对应的TCP内核发送缓冲区中，然后TCP模块调用IP模块提供的服务，TCP
报文段就是传递的参数。</p>

<p>　　UDP数据报不同之处在于，当一个UDP数据报成功发送以后，UDP内核缓冲区中的该数据就被丢弃了（没有ACK，这就是不可靠）。如果应用程序检测到接收端没有接收到，并且打算重新发送，那么应用程序就需要重新从用户空间将
该数据拷贝到内核缓冲区中。</p>

<p>　　IP数据报分为头部和数据两部分，数据部分就是一个TCP/UDP/ICMP报文段。</p>

<p>　　经过数据链路层封装后的数据称为帧（frame）。传输媒介不同则帧的类型也不一样，以太网上传输的是以太网帧，令牌环网上传输的是令牌环帧。以太网帧在IP数据报的基础上，前面增加6个字节的目的物理地址和6字节的源物理地址，
来表示通信的双方，再增加2字节的类型字段，然后是中间的IP数据报（46-1500字节），尾部增加4字节的CRC字段，提供循环冗余校验。</p>

<p>　　帧的最大传输单元（Max Transmit Unit， MTU），表示帧最多能够携带多少的上层协议数据（比如IP数据报），通常受到网络类型的限制，比如以太网帧的MTU是1500字节，也就是说，过长的IP数据报可能需要被分片（fragment）传输。</p>

<h3 id="二-ip协议">二、IP协议</h3>

<p>　　IP协议提供的是无状态、无连接、不可靠的服务。无状态指的是所有IP数据报的发送、传输和接受都是相互独立的，并没有上下文关系（这一点有点类似HTTP和UDP），这样导致的一个问题就是<strong>数据报可能是乱序的，也可能有重复</strong>，先发送的
数据报不一定就先到达接收端，接收端也无法检测到乱序和重复，只要收到了完整的IP数据报（如果是IP分片，IP模块会先执行重组），就将其数据部分（也就是一个TCP、UDP报文）交付给上层协议，比如TCP就会处理乱序重复问题。</p>

<h5 id="ip头部">IP头部</h5>

<p>　　IP数据报的头部提供了一个字段来唯一标识一个IP数据报，但它是用于IP分片和重组的，并不指示IP数据报的接受顺序。无连接指的是IP通信的双方并不记录对方的任何信息。不可靠指的是IP协议并不保证IP数据报能够准确到达接收端，
它只是承诺best effort。发送端的IP模块一旦检测到发送失败，就通知上层协议，不会自己重传，使用IP协议的上层协议（比如TCP），自己实现重传逻辑。</p>

<p>　　1、IPV4的数据报头部长度通常是20字节（固定部分），也可以包含最大长度为40字节的选项部分（可选部分），因此IP头部最长为60字节。</p>

<p>　　2、整个IP数据报的总长度最多为65535字节，但是由于MTU的限制，长度超过MTU的IP数据报都会被分片传输，因此实际传输的IP数据报（单个分片）的长度远远达不到65535的限制。</p>

<p>　　3、IP数据报头部还有一个16位的标识字段，唯一标识每一个IP数据报，这个值在分片的时候会复制到每一个IP分片中，因此属于同一个IP数据报的所有分片都有同一个标识（id）。</p>

<p>　　4、8位生存时间（Time To Live，TTL）是数据报到达目的地之前允许经过的路由器跳数。TTL值被发送端设置（常见的值是64）。数据报在转发过程中每经过一个路由，该值就被路由器减1。当TTL值减为0时，路由器将丢弃数据报，
并向源端发送一个ICMP差错报文。TTL值可以防止数据报陷入路由循环。</p>

<p>　　5、8位协议（protocol）用来区分上层协议，也就是区分IP数据报的数据部分，是TCP报文还是UDP报文等。</p>

<p>　　6、16位头部校验和（header checksum）由发送端填充，接收端对其使用CRC算法以检验IP数据报头部（注意，仅检验头部）在传输过程中是否损坏。</p>

<p>　　7、32位的源端IP地址和目的端IP地址用来标识数据报的发送端和接收端。一般情况下，这两个地址在整个数据报的传递过程中保持不变，而不论它中间经过多少个中转路由器。</p>

<h5 id="ip分片">IP分片</h5>

<p>　　当IP数据报大小超过MTU时，IP数据报会被分片，分片可能发生在发送端，也可能发生在中间的路由器上，甚至也可能多次分片；但是只有在最终的目的机器上，这些分片才会被重组，合成为一个完整的IP数据报。</p>

<p>　　一个IP数据报的每一个分片都具有自己的IP头部，它们拥有相同的标识（id），但是各自的片偏移（13位）不一样，并且除了最后一个分片以外，前面的每个分片都将设置MF（More Fragment）标志，每个分片的IP数据报总长度字段
被设置为各自分片的长度。如果按照以太网的MTU为1500字节计算，那么IP数据报的数据部分（也就是TCP报文段）的大小最多为1480字节。</p>

<h5 id="ip路由和转发">IP路由和转发</h5>

<p>　　这一部分设计到路由表，以及各类转发策略，路由表的更新维护等，并不作为重点学习。</p>

<h3 id="三-tcp协议详解">三、TCP协议详解</h3>

<p>　　TCP面向字节流而UDP面向数据报，这一点需要明白，TCP发送的时候也是以一个个的TCP报文发送出去的，那么这两种的区别对应在实际编程中，则表现为通信的双方是否需要执行相同次数的读写操作。当发送端应用程序连续执行多次写操作
时，TCP模块先将这些数据放入TCP发送缓冲区中。当TCP模块真正开始发送数据时，发送缓冲区中这些等待发送的数据可能被封装成一个或多个TCP报文段发出。因此，TCP模块发送出的TCP报文段的个数和应用程序执行的写操作次数之间没有固定的
数量关系。</p>

<p>　　当接收端接收到一个或者多个TCP报文段的时候，TCP模块将这些报文段所携带的应用程序数据按照TCP报文段的序号（位于TCP首部）依次放入TCP接收缓冲区，并通知应用程序读取数据（这里就是epoll，通知应用程序某个事件发生，也就是
应用程序收到通知时，TCP接收缓冲区（socket接收缓冲区）已经收到数据了，应用程序可以异步去读了）。接收端应用程序可以一次性将TCP接收缓冲区中的数据全部读出，也可以分多次读取，这取决于<strong>用户指定的应用程序读缓冲区的大小</strong>。
因此，应用程序执行的读操作次数和TCP模块接收到的TCP报文段个数之间也没有固定的数量关系。</p>

<p>　　也就是说，发送端执行的写操作次数和接收端执行的读操作次数没有任何数量关系，这就是字节流。而UDP不一样，发送端应用程序每执行一次写操作，UDP模块就将其封装成一个UDP数据报并发送之，接收端必须及时针对每一个UDP数据报执行
读操作（通过recvfrom系统调用），否则就会丢包。并且，如果用户没有指定足够大的应用程序缓冲区来读取UDP数据，则UDP数据还会被截断。</p>

<p>　　TCP传输是可靠的。首先，TCP协议采用发送应答机制，即发送端发送的每个TCP报文段都必须得到接收方的应答，才认为这个TCP报文段传输成功。其次，TCP协议采用超时重传机制，发送端在发送出一个TCP报文段之后启动定时器，如果在
定时时间内未收到应答，它将重发该报文段。最后，因为TCP报文段最终是以IP数据报发送的，而IP数据报到达接收端可能乱序、重复，所以TCP协议还会对接收到的TCP报文段重排、整理，再交付给应用层。</p>

<p>　　UDP协议则和IP协议一样，提供不可靠服务。它们都需要上层协议来处理数据确认和超时重传。</p>

<h5 id="tcp头部">TCP头部</h5>

<p>　　和IP头部一样，TCP头部的固定长度也是20字节，可选部分的长度为40字节，因此最大为60字节。</p>

<p>　　1、16位的源端口和目的端口号，通常客户端使用随机选择的临时端口号，服务端则使用知名端口号。如http这种就是80。</p>

<p>　　2、32位序号，一次TCP通信过程中某一个传输流方向上的字节流的 每个字节的编号。假设A和主机B进行通信，A发送给B的第一个TCP报文段中，序号被初始化为某个值（Initial Sequence Number， ISN），那么在该传输方向上，
后续的每个TCP报文段都序号值就是ISN + 该报文段携带的数据的第一个字节在整个字节流中的偏移。例如，某个TCP报文段传送的数据是字节流中的第1025～2048字节，那么该报文段的序号值就是ISN+1025。另外一个传输方向（从B到A）
的TCP报文段的序号值也具有相同的含义。</p>

<p>　　3、32位确认号（ACK），用作对对方发过来的TCP报文段的响应，它的值是收到的TCP报文段的序号值 + 1，主机A和B进行通信，那么A发送给B的TCP报文段中，不仅要包含自己的序号，也要包含对B发送过来的报文段的确认号。</p>

<p>　　4、6位标志位分别如下：</p>

<ul>
<li>URG标志：用于通知接收方，数据段内的某些数据是紧急数据，需要优先处理，不必进入缓冲区直接交付上层应用，配合着TCP的报头的16位紧急指针字段使用，但此标志位已经逐渐被淘汰，它需要配合Linux内核代码一起理解。</li>
<li>ACK标志：表示确认号是否有效，携带了ACK标志的报文叫做 <strong>确认报文段</strong>。连接建立后，这个字段一般都是1。</li>
<li>PSH标志：提示接收端应用程序应该立即从TCP接收缓冲区中读取走数据，为后面的数据腾出空间。正常情况下，发送方从应用层接收数据到缓冲区直到达到某个大小开始发送；接收方从缓冲区接收数据，
直到达到某个大小开始上报给用户层。在大多数情况下，这种工作模式是很有效率的。试想在要求实时交互通信的场景（比如启动一个 Telnet 连接）：一端的应用进程希望在键入一个命令后立即就能收到对方的响应。如果还是上述的工作模式，
有可能你输入的数据太少，未满足发送缓冲大小导致无法发送亦或者接收到的数据太小还没有投递到应用层，这样都会导致响应的不及时。引入PSH标志，一是提醒发送方立即发送这段数据，二是提示接收方立即将数据传给应用程序，不必等到缓冲
区满。</li>
<li>RST标志：表示要求对方重新连接，携带了RST标志的报文叫做 <strong>复位报文段</strong>。</li>
<li>SYN标志：表示请求建立一个连接，携带SYN标志的报文叫做 <strong>同步报文段</strong>。</li>
<li>FIN标志：表示通知对方本端要断开连接了，携带FIN标志的报文叫做 <strong>结束报文段</strong>。
<br /></li>
</ul>

<p>　　5、16位窗口大小（window size），这里的窗口指的是 接收窗口大小（Receiver Window， RWND），它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送的速度，用于流量控制。</p>

<p>　　6、16位校验和（TCP checksum）：由发送端填充，接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。注意，这个校验不仅包括TCP头部，也包括数据部分（作为对比，IP的校验和只校验头部）。这也是TCP可靠传输
的一个重要保障。</p>

<p>　　7、16位紧急指针（urgent pointer）：是一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP的紧急指针是发送端向接收
端发送紧急数据的方法。</p>

<p>　　上面是20字节的固定头部，其实还有最多40字节的可选部分，这里面的含义还比较多，挑几个重点的梳理一下：</p>

<p>　　1、最大报文长度选项（2字节）。TCP连接初始化时，通信双方使用这个选项来商议最大的报文段长度（Max Segment Size， MSS），TCP模块通常将MSS设置为（MTU-40）字节（减掉的这40字节包括20字节的TCP头部和20字节的IP头部
）。这样携带TCP报文段的IP数据报的长度就不会超过MTU（假设TCP头部和IP头部都不包含选项字段，并且这也是一般情况），从而避免本机发生IP分片。对以太网而言，MSS值是1460（1500-40）字节。</p>

<p>　　参考： <a href="https://draveness.me/whys-the-design-tcp-segment-ip-packet/">TCP/IP协议如何拆分数据</a></p>

<p>　　注意，这里说明了一点，在建立连接的TCP报文段里，TCP首部是包含了可选部分的（因为要确定MSS），但是在后续的发送数据过程中，往往是不包含选项部分的，就不用再次确立了。</p>

<p>　　2、窗口扩大因子选项（1字节）。也是在TCP连接初始化的时候，通信双方用来协商 <strong>接收窗口</strong>的扩大因子。在固定首部中，接收窗口大小是16位，最大是65535字节，但实际上TCP模块允许的接收窗口大小远远不止这个数字，这就是窗口
扩大因子的作用。假设TCP头部中的接收窗口大小是M，窗口扩大因子是N，则<strong>实际的接收窗口大小等于</strong> M * 2^N（即M左移N位），扩大因子的取值为0~14，这个数字位于/proc/sys/net/ipv4/tcp_window_scaling，这个内核变量中，
可以动态修改之。</p>

<p>　　和上面的MSS一样，窗口扩大因子选项也只能出现在同步报文段中（只是在建立连接的报文），否则将被忽略。但是同步报文段本身并不执行窗口扩大操作，即同步报文段头部的接收通告窗口大小就是该TCP报文段的实际接收通告窗口大小。当
连接建立好之后，每个数据传输方向的窗口扩大因子就固定不变了。</p>

<p>　　3、选择性确认选项（Selective Acknowledgment）。TCP通信时，如果某个TCP报文段丢失，则TCP模块会重传<strong>最后被确认的TCP报文段后续的所有报文段</strong>，这样原先已经正确传输的TCP报文段也可能重复发送，从而降低了TCP性能。
SACK技术正是为改善这种情况而产生的，它使TCP模块只重新发送丢失的TCP报文段，不用发送所有未被确认的TCP报文段。选择性确认选项用在连接初始化时，表示是否支持SACK技术。可以通过修改/proc/sys/net/ipv4/tcp_sack内核变量来
启用或关闭选择性确认选项。一般都设置为1了。</p>

<h5 id="tcp连接建立与关闭">TCP连接建立与关闭</h5>

<p>　　三次握手的连接建立流程和四次挥手的连接断开流程本身没有太多说的，关于三次握手有一篇比较好的参考文章 <strong><a href="https://draveness.me/whys-the-design-tcp-three-way-handshake/">为什么TCP建立连接是三次握手</a></strong>。
这篇文章写得<strong>非常好</strong>，因为它剖析了三次握手的根本原因是将是否建立连接的最终控制权交给了发送方，因为只有发送方有足够的上下文来判断当前连接是否是错误的或者过期的。</p>

<p>　　为什么需要三次握手才能建立连接，首先需要理解并且明确的就是，这个<strong>连接</strong>到底是什么含义？RFC793关于TCP的介绍里有这样一段话：</p>

<pre><code>The reliability and flow control mechanisms described above require that TCPs initialize 
 and maintain certain status information for each data stream. The combination of 
 this information, including sockets, sequence numbers, and window sizes, 
 is called a connection.
</code></pre>

<p>　　这里对连接的解释其实就是一些状态信息，即通信的双方需要维护的状态信息，包括socket、序列号以及窗口大小。连接的作用是什么呢？用来保证可靠性以及流量控制。所以建立TCP连接就是通信的双方需要对这几条信息达成共识。socket
就是IP地址+端口号，标识一个应用进程；窗口大小用于进行流量控制；序列号用来唯一标识和追踪发送方发送的数据报，接收方可以通过将收到的数据报序号 + 1作为ack号发回对方，表示已接收到。</p>

<p>　　现在的问题就转化为，为什么需要三次握手才可以确认socket、序列号以及窗口大小？这里有两个非常重要的原因：当然其实socket（端口号）和窗口大小（接收窗口大小）都是直接在TCP报文段的固定首部中，所以在握手的过程中就商量
好了。</p>

<ul>
<li><p>1） 通过三次握手才能阻止历史重复连接的初始化（最主要原因），还是先来看RFC793官方文档里怎么说的：</p>

<p>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion</p></li>
</ul>

<p>　　这里就指出了使用三次握手的首要原因是——为了阻止历史重复连接造成的混乱问题，防止通信双方建立了错误的连接。假设有这样一个场景：在网络情况较差时，发送方连续发起了建立连接的请求，如果 TCP 建立连接只能通信两次，那么接收
方只能选择接受或者拒绝发送方发起的请求，它并不清楚这一次请求是不是由于网络拥堵而早早过期的连接。所以TCP引入了三次握手并在在TCP头部弄了一个RST标志位来辅助，接收方收到第一次握手请求时，会将收到的SEQ + 1作为ack发送给
对方，这样就由发送方来判断当前连接是否是历史连接。</p>

<p>　　a. 如果当前连接是历史连接，比如发送方连续发送了SEQ为90和100的两个请求，因为网络环境比较差，我认为90那个已经无效了，我现在期望收到的ack是101，但是接收端发过来的ack是91，那么发送方就认为收到的这个91报文是已经
过期的了，就直接发送一个RST报文表示让对方重新发。
　　b. 如果当前连接不是历史连接，发送方就直接发送ack回去，这样双方就建立好了连接。</p>

<p>　　使用三次握手和 RST 控制消息将是否建立连接的最终控制权交给了发送方，因为<strong>只有发送方有足够的上下文来判断当前连接是否是错误的或者过期的</strong>，这也是 TCP 使用三次握手建立连接的最主要原因。</p>

<ul>
<li>2） 通信双方都需要获得一个用于发送信息的初始化序列号，这就是TCP可靠的基石。因为在复杂的网络环境中，加之IP协议并不可靠，可能会导致很多问题。比如：
数据包被多次发送导致接收端收到重复的数据报，数据包丢失，数据包的接收顺序可能和发送顺序不一致（即顺序混乱）。</li>
</ul>

<p>　　为了解决上面这几个问题，TCO头部有一个序列号字段SEQ，每一个数据包都有一个对应的序列号，接收方就可以通过序列号进行去重；发送方在没有收到相关数据包
的ack时，会进行重传；接收方可以利用数据包的序列号对它们进行重排序。</p>

<p>　　两次握手至少让一端无法确定对端是否了解了你的起始序列号。即，假设我是服务端。对端syn给我发了序列号，我也给对端回了我的序列号，但是如果我给对方发的这个数据包丢了怎么办？于是我没法确认对端是否收到，
所以需要对端再跟我确认一下他确实收到了。</p>

<p>　　除此之外，网络作为一个分布式的系统，其中并不存在一个用于计数的全局时钟，而 TCP 可以通过不同的机制来初始化序列号，作为 TCP 连接的接收方我们无法
判断对方传来的初始化序列号是否过期，所以我们需要交由对方来判断，TCP 连接的发起方可以通过保存发出的序列号判断连接是否过期，如果让接收方来保存并判断序列
号却是不现实的，这也再一次强化了我们在上一节中提出的观点 —— 避免历史错连接的初始化。所以本质上，这个序列号也是在解决第一个问题，非常有意义。</p>

<h6 id="1-半关闭状态">（1）  半关闭状态</h6>

<p>　　由于TCP是一个全双工协议，因此它允许只有一个方向的数据传输，即两个方向的数据传输可以各自分别关闭，发送端可以发送结束报文（FIN）给对方，告诉对方我已经完成了数据的发送，但是此时我仍然可以接收数据，直到对方也发送了
结束报文段来关闭连接，这种状态就是半关闭状态。</p>

<h6 id="2-连接超时">（2）  连接超时</h6>

<p>　　假设由于网络情况不佳，客户端发送的第一个同步报文段（SYN）丢失了，或者接收端对这个报文段的响应（ACK、SYN，同时也是一个同步报文段）丢失了；那么客户
端首先要进行重连（多次），多次后仍然无效则通知应用程序连接超时。连接超时次数是由内核变量/proc/sys/net/ipv4/tcp_syn_retries定义的，每次重新连接的
超时时间都会增加一倍。注意，这个是连接超时次数，即syn_retries，不是后面的数据报超时重传次数，两者是不太一样的。</p>

<h5 id="tcp状态转移">TCP状态转移</h5>

<p>　　TCP状态转移图这里不再画出，各类经典书籍中都会有。TCP连接的任意一端在任意一个时刻都一定处于某种状态，从连接建立到关闭的整个过程中状态不断变化，
下面会分别针对服务端和客户端描述一下这个过程。</p>

<p>　　1、首先是服务端，服务端通过listen系统调用进入<strong>LISTEN</strong>状态，被动等待客户端的连接；</p>

<p>　　2、服务端一旦监听到某个连接请求（收到同步报文段，即第一次握手SYN），就将该连接（<strong>对应内核中的结构体 inet_request_sock</strong>）放入内核等待队列
（也叫SYN队列，或者叫半连接队列），并向客户端发送带SYN标志、ACK标志的确认报文段（即第二次握手的ack），此时服务端的连接进入<strong>SYN_RCVD</strong>状态；</p>

<p>　　3、服务端接收到了客户端的确认报文段（第三次握手的ack），首先找到对应的SYN队列，再在队列中检查相关的数据是否匹配（因为这个ack包可能是其他的一个
客户端发过来的），如果匹配，内核就将SYN队列中的该连接（以及相关数据）移除，创建一个完整的连接（<strong>对应内核结构体 inet_sock</strong>），并将这个完整的连接
放入Accept队列（也叫全连接队列），此时服务端的连接进入<strong>ESTABLISHED</strong>状态。这个状态是连接双方能够进行双向数据传输的状态。</p>

<p>　　4、当客户端主动发起关闭连接的请求时（通过close或者shutdown系统调用想服务端发送结束报文段），服务器返回确认报文段ack后，服务端连接进入
<strong>CLOSE_WAIT</strong>状态。含义是：我已经知道你要关闭连接了，我也等待自己服务端应用程序关闭连接。一般情况下，服务端收到客户端的FIN包时，也会立即发送给
客户端一个FIN包来关闭连接，发送FIN包后，服务端连接进入<strong>LAST_ACK</strong>状态，以等待客户端的最后一次确认。一旦收到后，连接就彻底关闭了。</p>

<p>　　接下来讨论一下客户端的连接转移过程：</p>

<p>　　1、客户端通过connect系统调用主动与服务端建立连接，connect系统调用首先发送给服务器发送一个同步报文段（对应前面服务端收到的第一个握手请求），此时
客户端；连接进入<strong>SYN_SENT</strong>状态，然后，connect系统调用可能会由于下面两个原因而失败返回：</p>

<ul>
<li>1） 如果connect的目标端口不存在（未被任何服务端应用进程监听），或者该端口仍被<strong>处于TIME_WAIT状态的连接所占用</strong>，则服务端给客户端发送一个复位
报文段（RST标志），connect调用失败；</li>
<li>2） 如果目标端口存在，但是connect在超时时间内没有收到服务端发送的确认报文段，则调用失败。</li>
</ul>

<p>　　2、connect调用失败则客户端连接进入初始的<strong>CLOSE</strong>状态，如果客户端收到了服务端发送的SYN+ACK报文段，则connect系统调用返回成功，客户端连接进入
<strong>ESTABLISHED</strong>状态，并给服务端发回ack（第三次握手）。</p>

<p>　　3、当客户端主动发起关闭连接请求时，它向服务端发一个FIN结束报文段，同时客户端连接进入<strong>FIN_WAIT_1</strong>状态；如果此时客户端收到了服务端对于这个关闭
连接请求的ack，那么客户端连接转移到<strong>FIN_WAIT_2</strong>状态，此时服务端是处于CLOSE_WAIT状态的。这一对状态就是发生在前面提到的半关闭时刻。如果服务端也
关闭连接（发送FIN报文段），则客户端收到后将发回最后一个ACK确认，并进入<strong>TIME_WAIT</strong>状态。</p>

<p>　　值得注意的是，客户端是有可能直接从FIN_WAIT_1状态进入TIME_WAIT状态的（即不经过FIN_WAIT_2状态），也就是服务端不是先发送一个ack，再发送一个
FIN，而是把这两个合并到一个报文段中进行发送（即ACK + FIN报文），</p>

<h5 id="问题一-现在一个问题-服务端还会经过close-wait状态吗-理论上应该也没有了吧">问题一：现在一个问题，服务端还会经过CLOSE_WAIT状态吗？理论上应该也没有了吧。</h5>

<p>　　前面提到了，客户端由FIN_WAIT_2进入TIME_WAIT状态的条件是 收到了服务端发起的主动关闭连接请求（服务端的FIN报文），否则客户端将一直停留在这个状态；然而，如果不是为了在半关闭状态下继续接收数据，连接长时间的停留在
FIN_WAIT_2状态没有什么好处。连接停留在这个状态的原因之一可能是：客户端主动关闭连接后，也收到了服务端的ack，但是还没有等到服务端执行关闭连接，客户端就强行退出了，此时客户端的连接由内核接管，也叫作<strong>孤儿连接</strong>。Linux
为了防止孤儿连接长时间的留存在内核中，定义了两个内核变量： /proc/sys/net/ipv4/tcp_max_orphans和/proc/sys/net/ipv4/tcp_fin_timeout。前者指定内核能接管的孤儿连接个数，后者指定孤儿连接的存活时间。</p>

<p>　　<strong>这里并没有讨论一些特殊情况，比如连接的同时打开和同时关闭。</strong></p>

<h6 id="time-wait状态">TIME_WAIT状态</h6>

<p>　　客户端在收到服务端的结束报文段时（FIN），发回ack，并没有直接进入CLOSE状态，而是到了一个TIME_WAIT状态。客户端连接会在TIME_WAIT状态等待一段2 * MSL（Maximum Segment Life，TCP报文段在网络中的最大生存时间）
时间，然后才完全关闭。TIME_WAIT状态存在主要有两个原因：</p>

<ul>
<li><p>1） 保证让迟到的TCP报文段有足够时间被接收或者被丢弃。假设在半关闭状态下，服务端还想最后发送给客户端一个数据报，然后接着发送了FIN关闭连接，但是由于网络环境，客户端先收到了FIN包，如果直接关闭，那么就无法处理数据报了，
这样就不符合可靠的定义了，所以需要等一会，等等那些迟到的TCP报文段。</p></li>

<li><p>2） 可靠地终止TCP连接。假设 客户端发回的最后一个ack（对于服务端关闭连接的确认）包丢失了，那么服务端由于没有收到自己关闭连接请求的ack，那么服务端必然会重新发送自己的关闭连接请求（重新发送FIN包），那么客户端必须要
停留在某个状态以处理这种重新发发送的FIN请求。否则，客户端收到一个不存在的连接的包，将发送一个复位报文RST给服务端，服务端收到RST则明显是错误的，因为它期望收到的是一个正常的ACK。</p></li>
</ul>

<p>　　在Linux系统上，同一个端口不能被同时打开，当一个TCP连接处于TIME_WAIT状态时，是不能使用该连接占用的端口来新建一个新的连接的。假设不存在这个状态，那么当旧的TCP连接发回ack以后，立即进入CLOSE，然后应用程序马上就
可以使用同一个端口新建一个<strong>相似的连接</strong>（准确来说，就是IP + 端口号一致），这个新的连接是仍然有可能接收到<strong>本应该属于旧连接的、携带数据的、迟到的TCP报文段（在半关闭状态下），和1）极其相似的情况</strong>，这样显然是不合理
的，即必须要存在TIME_WAIT状态的另外一个原因，其实还是一个道理，必须等待一段时间处理那些迟到的TCP报文数据。</p>

<p>　　有时候我们希望避免TIME_WAIT状态，因为当程序退出后，我们希望能够立即重启它。但由于处在TIME_WAIT状态的连接还占用着端口，程序将无法启动（直到2MSL超时时间结束）。对客户端程序来说，我们通常不用担心上面描述的重启问题。
因为客户端一般使用系统自动分配的临时端口号来建立连接，而由于随机性，临时端口号一般和程序上一次使用的端口号（还处于TIME_WAIT状态的那个连接使用的端口号）不同，所以客户端程序一般可以立即重启。</p>

<p>　　但如果是服务器主动关闭连接后异常终止，则因为它总是使用同一个知名服务端口号，所以连接的TIME_WAIT状态将导致它不能立即重启。不过，我们可以通过socket选项SO_REUSEADDR来强制进程立即使用处于TIME_WAIT状态的连接占用的
端口，后面还会梳理这个问题。</p>

<p>　　你必须要意识到的一个问题是：只有主动关闭连接的一方，才会出现TIME_WAIT状态，而这个主动关闭，服务端和客户端均有可能。</p>

<h5 id="问题二-那么你可以思考这样一个问题-我们目前的rpc服务方-就是一台机器上的一个进行-仅使用一个端口-那么为了保证端口可重用-服务方是不是必须使用socket的so-reuseaddr选项-或者就是服务端永远不会主动关闭连接-主动关闭连接的操作都由客户端来进行-是这样吗">问题二：那么你可以思考这样一个问题，我们目前的RPC服务方，就是一台机器上的一个进行，仅使用一个端口，那么为了保证端口可重用，服务方是不是必须使用socket的SO_REUSEADDR选项，或者就是服务端永远不会主动关闭连接，主动关闭连接的操作都由客户端来进行？是这样吗？</h5>

<h5 id="复位报文段">复位报文段</h5>

<p>　　在一些特殊情况下，TCP连接的一端会向另一端发送带RST标识的复位报文段，主要有以下几种情况：</p>

<ul>
<li><p>（1） 访问不存在的端口（未被监听的），则服务端会返回一个RST报文段，RST报文段中首部的接收窗口大小是0，因此收到RST报文段的一方应该关闭连接，或者重新尝试连接，而不能回复这个RST报文段。实际上，前面客户端connect系统
调用时提到了，除了访问不存在的端口以外，如果该端口仍然被处于TIME_WAIT状态的连接所占用的时候，客户端也会收到RST报文段。这里可以思考RPC服务方是怎么避免端口被TIME_WAIT占用的。</p></li>

<li><p>（2） 异常终止连接：TCP提供了一个异常终止一个连接的方法——给对方发送一个复位报文段，一旦发送了RST，发送端所有等待发送的数据都会被丢弃。应用程序
可以使用socket选项SO_LINGER来发送复位报文段，以异常终止一个连接。</p></li>

<li><p>（3） 处理半打开连接：有这样一种情况，服务端主动关闭或者异常的终止了连接，而此时客户端没有收到FIN报文段（网络故障），所以客户端还是维持着原来的连接，
正常的往服务端发送数据，服务端即使重启也没用原来的连接信息了，这种状态就是半打开状态，处于这种状态的连接就是半打开连接，客户端相当于往一个半打开的连接中
写入数据，此时服务端正常它是希望接收到ack的（即对于我那次FIN包的ack），所以它不理解这些数据，回复一个RST报文段。</p></li>
</ul>

<h5 id="tcp交互数据流">TCP交互数据流</h5>

<p>　　TCP报文段携带的应用程序数据，按照长度可以分为两种：交互数据流和成块数据流，交互数据流包含的字节一般较少，使用交互数据流的应用程序对实时性一般要求
较高；成块数据流的数据长度一般就是TCP报文段允许的最大长度，这种应用程序一般对吞吐量要求较高（比如ftp）。</p>

<p>　　服务端的延迟确认：服务端每次发送的确认报文段都包含它需要发送的应用程序数据，即它不马上确认收到的数据，而是在一段时间延迟后，查看本端是否有需要发送
的数据，如果有就和确认信息一起发出。延迟确认可以减少发送的TCP报文段数目。</p>

<p>　　这里在广域网中往往也会引入新的问题，即广域网上的微小TCP报文段数目非常多，数据流延迟也飘忽不定，这些因素会导致<strong>拥塞</strong>发生，解决拥塞的一个简单
算法就是<strong>Nagle算法</strong>。</p>

<p>　　Nagle算法要求，TCP连接的双方在任意时刻都只能发送一个未被确认的TCP报文段，在这个报文段的ack收到之前，不能发送其他的报文段；另一方面，发送方在
等待ack的同时，也收集本端需要发送的微小数据，等到ack到达时以一个TCP报文段将它们全部发出，这样极大的减少网络上的微小TCP报文段数量。</p>

<h5 id="tcp成块数据流">TCP成块数据流</h5>

<h5 id="带外数据流">带外数据流</h5>

<p>　　TCP和UDP都没有带外数据，带外数据用于告诉对方我这边有一些重要事件，优先级比普通的数据要高，TCP就是利用头部的URG标识和紧急指针两个字段来实现的，
TCP的紧急方式利用传输普通数据的连接来传输紧急数据。这种紧急数据的含义和带外数据类似。</p>

<h5 id="tcp超时重传">TCP超时重传</h5>

<p>　　重传指的是，在一定超时时间内，发送方没有收到已经发送的数据报的确认，那就需要重传。因此，TCP模块为每一个TCP报文段都维护了一个重传定时器，这个定时器
在TCP报文段被第一次发送时启动，如果超时时间内仍然没有收到这个报文段的确认（当然服务端是可以一次确认多个的），那么就重传报文段并重启定时器，至于后续每
依次重传的超时时间以及重试次数，是由重传策略决定的。</p>

<p>　　虽然超时会导致TCP报文段的重传，但是TCP报文段的重传是可能发生在超时之前的，即<strong>快速重传</strong>。</p>

<h5 id="tcp拥塞控制">TCP拥塞控制</h5>

<p>　　TCP模块除了超时重传保证可靠性以外，还需要提高网络带宽利用率，降低丢包率，并保证网络资源对每条数据流的公平性，这就是拥塞控制。拥塞控制的四个部分
分别是：慢启动（slow start）、拥塞避免（congestion avoidance）、快速重传（fast retransmit）和快速恢复（fast recovery）。拥塞控制算法
在Linux下有多重实现，比如reno算法、vegas算法和cubic算法等。它们或者部分或者全部实现了上述四个部分。
/proc/sys/net/ipv4/tcp_congestion_control文件指示机器当前所使用的拥塞控制算法。现在一般的实现都是cubic算法。</p>

<p>　　拥塞控制的最终受控变量是发送端向网络一次连续写入的数据量（这里是应用程序向TCP发送缓冲区，还是发送缓冲区向网卡？），称之为SWND（Send Window，
发送窗口）。发送端最终是以TCP报文段来发送数据的，所以SWND限定了发送端能够连续发送的报文段数量，这些TCP报文段的最大长度（仅数据部分）称为SMSS（
Sender Maximum Segment Size，发送者最大段大小），一般就等于MSS。</p>

<p>　　实际的SWND等于 发送端的拥塞窗口（Congestion Window， CWND）和 接收端的 接收窗口（RWND）之间的较小者。</p>

<h6 id="慢启动和拥塞避免">慢启动和拥塞避免</h6>

<p>　　TCP连接建立好以后（三次握手结束），CWND被设置成初始值IW（Initial Window），一般是2~4个SMSS，现在新的Linux内核一般不止这个数字，此时发送端
最多能发送IW个字节的数据，此后发送端每收到一个接收端的确认，就调整其拥塞窗口大小：</p>

<pre><code>CWND += min(N, SMSS)
</code></pre>

<p>其中，N是此次确认中包含的之前未被确认的字节数，这样的过程就是慢启动，因为TCP模块刚开始发送数据时不知道网络的实际情况，因此用一种比较平滑的方式增加
CWND的大小。</p>

<p>　　但是很快CWND就会变得非常大，并最终导致网络拥塞，因此TCP拥塞控制中定义了一个慢启动门限变量（slow start threshold size），当CWND大小超过
这个值时，拥塞控制将会进入拥塞避免阶段。</p>

<p>　　拥塞避免算法主要是减缓CWND的增长速度，RFC中提到了两种实现方式：</p>

<ul>
<li>（1）每个RTT时间内按照上面的公式计算新的CWND，而不论该RTT时间内发送端收到多少个确认；</li>

<li><p>（2）每收到一个对新数据的确认报文段，就按照下面新的公式来计算CWND。</p>

<p>CWND += SMSS * SMSS/CWND</p></li>
</ul>

<p>　　上面是发送端在未检测到拥塞时所采用的的 积极避免拥塞的办法，下面两个部分是 发送端检测到拥塞发生时所采用的的方法，检测到拥塞可能是在慢启动阶段，也可
能是在拥塞避免阶段，发送端判断拥塞发生的依据有下面两个：</p>

<ul>
<li>（1） 传输超时，或者说TCP重传定时器溢出；如果是这种情况，发送端仍然使用慢启动和拥塞避免来处理，这里涉及到调整慢启动门限ssthreshold值。</li>
<li>（2） 接收到重复的确认报文段。如果是这种情况，发送端使用快速重传和快速恢复来解决拥塞。</li>
</ul>

<h6 id="快速重传和快速恢复">快速重传和快速恢复</h6>

<p>　　前面提到，接收到重复的确认报文段时，拥塞控制算法还需要判断是否是真正的发生了拥塞，更具体来说就是判断TCP报文段是否真的丢失了，具体做法是：
发送端如果连续收到了3个重复的确认报文段，就认为发生了拥塞，然后它启用快速重传和快速恢复来处理拥塞。</p>

<p>　　</p>

    </div>

    
    


    
    

    <footer class="post-footer">
      <div class="post-tags">
          <a href="https://monkback.github.io/tags/linux/">Linux</a>
          <a href="https://monkback.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a>
          
        </div>

      
      <nav class="post-nav">
        
        
          <a class="next" href="/post/algorithm/leetcode/leetcode-trie/">
            <span class="next-text nav-default">Leetcode-字典树</span>
            <span class="prev-text nav-mobile">Next</span>
            
            <i class="iconfont">
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

            </i>
          </a>
      </nav>
    </footer>
  </article>

  
  

  
  

  

  
  

  

  

  

    

  

        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="icon-links">
  


<a href="https://monkback.github.io/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
   
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    
      2017 -
    2020
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span></span>

  
  

  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.dee43230127a73d039a734510fa896c89c3c7ce0cf0be0c7a7433f8fd69b76dc.js" integrity="sha256-3uQyMBJ6c9A5pzRRD6iWyJw8fODPC&#43;DHp0M/j9abdtw=" crossorigin="anonymous"></script>


























</body>
</html>
