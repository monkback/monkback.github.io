<!DOCTYPE html>
<html lang="zh-cn" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>读方腾飞的《Java 并发编程的艺术》 - Records</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">


  <meta name="description" content="之前粗略的看过一次这本书，但是那时候基础知识并不好，有很多地方都看得云里雾里的，这次再尝试读一遍。 第一章里提到，我们都知道如果用多线程就会导" />







<meta name="generator" content="Hugo 0.57.2" />


<link rel="canonical" href="https://monkback.github.io/post/juc/theartofconcurrencyprogramming/" />



<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.af20b78e95c84de86b00a0242a4a77bd2601700e1b250edf27537d957ac0041d.css" integrity="sha256-ryC3jpXITehrAKAkKkp3vSYBcA4bJQ7fJ1N9lXrABB0=" media="screen" crossorigin="anonymous">





<meta property="og:title" content="读方腾飞的《Java 并发编程的艺术》" />
<meta property="og:description" content="之前粗略的看过一次这本书，但是那时候基础知识并不好，有很多地方都看得云里雾里的，这次再尝试读一遍。 第一章里提到，我们都知道如果用多线程就会导" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://monkback.github.io/post/juc/theartofconcurrencyprogramming/" />
<meta property="article:published_time" content="2020-05-06T18:08:29+08:00" />
<meta property="article:modified_time" content="2020-05-06T18:08:29+08:00" />
<meta itemprop="name" content="读方腾飞的《Java 并发编程的艺术》">
<meta itemprop="description" content="之前粗略的看过一次这本书，但是那时候基础知识并不好，有很多地方都看得云里雾里的，这次再尝试读一遍。 第一章里提到，我们都知道如果用多线程就会导">


<meta itemprop="datePublished" content="2020-05-06T18:08:29&#43;08:00" />
<meta itemprop="dateModified" content="2020-05-06T18:08:29&#43;08:00" />
<meta itemprop="wordCount" content="6026">



<meta itemprop="keywords" content="Java并发," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="读方腾飞的《Java 并发编程的艺术》"/>
<meta name="twitter:description" content="之前粗略的看过一次这本书，但是那时候基础知识并不好，有很多地方都看得云里雾里的，这次再尝试读一遍。 第一章里提到，我们都知道如果用多线程就会导"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->




</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Records</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://monkback.github.io/post/">Blog</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://monkback.github.io/categories/">Categories</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://monkback.github.io/tags/">Tags</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://monkback.github.io/about/">About</a>
          
        
      </li>
    

    
  </ul>
</nav>


  

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      Records
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://monkback.github.io/post/">Blog</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://monkback.github.io/categories/">Categories</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://monkback.github.io/tags/">Tags</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://monkback.github.io/about/">About</a>
          

        

      </li>
    

    
    

    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">读方腾飞的《Java 并发编程的艺术》</h1>
      
      <div class="post-meta">
        <time datetime="2020-05-06" class="post-time">
          2020-05-06
        </time>
        
        

        
        

        
        
      </div>
    </header>

    
    

    
    <div class="post-content">
      <p>　　之前粗略的看过一次这本书，但是那时候基础知识并不好，有很多地方都看得云里雾里的，这次再尝试读一遍。</p>

<p>　　第一章里提到，我们都知道如果用多线程就会导致线程的上下文切换，而这一过程是比较耗时的。减少上下文切换次数的方法主要有以下几个：</p>

<ul>
<li><p>1、使用无锁编程。多个线程在竞争锁的时候，会引起上下文切换；所以可以在某些时候尝试不使用锁来达到线程安全的目的，比如使用ThreadLocal；</p></li>

<li><p>2、CAS。比如使用juc中的Atomic包下的一些类；</p></li>

<li><p>3、协程。不知道Java里面有没有这个，但是这是go的核心，大概是在一个线程中实现多个任务的调度，并维护这些任务的切换，所以这就是你要好好学习go的原因之一。</p></li>
</ul>

<p>　　<strong><big>第二章：</big></strong></p>

<p>　　<strong>volatile：</strong></p>

<p>　　能够保证被修饰的变量具有可见性，即所有线程(可能在不同的CPU上执行)读取到的这个变量
都是一致的；因为volatile变量在被修改(写入)的时候，编译后的汇编代码会多出一行Lock开头的指令，lock前缀指令在多核处理器下会
引发两件事情：</p>

<ul>
<li><p>1、将当前处理器缓存行(cache line，缓存的最小单位，一般为64byte)的数据写回到系统内存(memory)；</p></li>

<li><p>2、这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效(<strong>缓存一致性协议</strong>，每个处理器都在嗅探总线上传播的数据来
检查自己的缓存是否已经过期)</p></li>
</ul>

<p>　　讲了一个volatile优化的常用例子，Doug Lea在JDK1.7的并发包里增加的LinkedTransferQueue类就使用了<strong>字节追加</strong>的
策略来优化队列的性能；将共享变量(头节点和尾节点)追加到64个字节，即一个L1、L2或L3级缓存的缓存行大小，从而避免头节点和尾节点被
加载到同一个缓存行，使得头尾节点在修改时不会相互锁定。至于为什么会锁定呢？这里又回到了<strong>缓存一致性协议</strong>：当一个处理器试图修改
头节点时，会将整个缓存行锁定，那么在缓存一致性机制的作用下，会导致其他处理器不能访问自己缓存中的尾节点，而本身队列的入队和出队
操作需要不停的修改头节点和尾节点(这是一个链表实现的队列结构)，因此大大影响了队列的效率。这里要求你必须严格理解缓存一致性协议，
需要单独写一篇博客来充分理解。不过在共享变量不会被频繁的写的情况下，或者是缓存行非64byte时，就没必要追加64字节了。</p>

<p>　　<strong>synchronized：</strong></p>

<p>　　synchronized实现同步的基础在于<strong>每一个Java对象都可以作为锁</strong>，而这个锁存储在<strong>Java对象头中</strong>，可以作用在实例方法、
静态方法或者是方法块上。实例方法锁的是当前实例对象，静态方法锁的是当前类的Class对象，方法块上锁的是synchronized括号里面配置
的对象。代码块同步使用的是monitorenter和monitorexit指令实现的，方法同步并不是(同步方法是依靠<strong>方法修饰符ACC_SYNCHRONIZED</strong>)。monitorenter指令是在编译后插入到同步代码
块开始的位置，monitorexit指令插入到方法结束处和异常处。任何对象<strong>都有一个monitor与之关联</strong>。</p>

<p>　　如果Java对象是数组类型，则JVM用3个字宽(Word)存储对象头，否则用2个字宽；多的一个字宽是存储数组长度的。在32位虚拟机中，1个
字宽就是32位，即4byte；64位虚拟机就是64位，即8byte。Java对象头主要存储的内容如下：</p>

<ul>
<li>1、Mark Word：存储对象的hashcode或锁信息(<strong>包括锁的标志位，一般用2bit，是否偏向锁，用1bit</strong>)</li>
<li>2、Class Metadata Address：存储到对象类型数据的指针</li>
<li>3、Array Length：数组的长度(如果对象是数组的话)</li>
</ul>

<p>　　在运行期间，Mark Word里存储的数据会随着锁标志位的变化而变化。锁一共有四种状态，级别从低到高以此是：无锁状态、偏向锁状态、
轻量级锁状态和重量级锁状态。这几个状态会随着竞争情况逐渐升级，且只能升级无法降级。</p>

<p>　　大多数情况下，锁不存在多线程竞争，而且总是由同一个线程获得，为了让线程获取锁的代价更低因引入了<strong>偏向锁</strong>，线程在进入同步块的
时候先不需要进行CAS操作来加锁，只是测试一下当前对象头的Mark Word里面<strong>是否存储着指向当前线程的偏向锁</strong>，如果是，则成功获取锁
，否则<strong>再检查一下当前对象头中Mark Word的偏向锁标识是否已经设置</strong>：如果没有设置，则使用CAS竞争锁；如果设置了，则<strong>尝试使用
CAS操作将当前对象头的偏向锁指向该线程</strong>。这里可以看到，似乎不管是竞争锁还是将对象头的偏向锁指向线程，都是使用的CAS操作。
可以通过JVM参数来关闭偏向锁，这样程序会默认进入轻量级锁状态。</p>

<p>　　轻量级锁就比较有意思了，它的加锁过程是：线程在执行同步块代码前，JVM会先在<strong>当前线程的栈帧</strong>中创建用于<strong>存储锁记录的空间</strong>
，并将对象头中的Mark Word<strong>复制到锁记录中</strong>，这一步叫做Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word
替换为指向锁记录的指针，如果成功则表示获取到了锁，否则表示其他线程也在竞争这个锁，当前线程会尝试自旋。</p>

<p>　　解锁过程就是相反，使用CAS操作将之前复制在锁记录中的Mark Word替换回对象头，成功则表示释放成功，失败则表示存在竞争，锁此时
会<strong>膨胀为重量级锁</strong>。</p>

<pre><code>锁            优点                                     缺点                                      适用场景        
偏向锁      加锁和解锁不需要额外的消耗，和执行非     如果线程之间存在锁竞争，则会带来额外的      只有一个线程访问同步块
            同步方法相比仅存在纳秒级别的差距        锁撤销的消耗
轻量级锁    竞争的线程不会阻塞，而是自旋，提高了响应速度     始终得不到锁的线程会一直自旋消耗CPU  追求响应时间，同步块执行速度较快
重量级锁    线程竞争不会自旋，不消耗CPU            线程会阻塞，响应时间会变长                追求吞吐量，同步块执行速度较慢
</code></pre>

<p>　　处理器提供了缓存锁定(缓存一致性协议)和总线锁定两个机制来保证某些操作的原子性，但是注意锁总线开销较大，使用场景并不多。Java中
一般采用CAS操作和锁来保证某个操作的原子性，但需要注意的是CAS引发的ABA问题，解决方案是增加一个版本号，每次变量更新时版本号加一，
JDK的<strong>Atomic包</strong>提供了一个类AtomicStampedReference来解决ABA问题，这个类的compareAndSet方法的作用是首先检查当前引
用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>

<p>　　<strong><big>第三章：</big></strong></p>

<p>　　在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序，主要分为下面三种，其中第一种是编译器重排序，后面是处理器
重排序。</p>

<ul>
<li>1、编译器优化的重排序，在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序；</li>
<li>2、指令级并行的重排序，现代处理器采用了指令级并行技术将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变指令执行顺序</li>
<li>3、内存系统重排序，由于处理器使用缓存(L1、L2和L3)和读/写缓冲区，这使得Load和Store操作看上去可能是乱序的。</li>
</ul>

<p>　　对于编译器重排序，JMM的编译器重排序规则会禁止特定类型的编译器重排序。而对于处理器重排序，JMM的处理器重排序规则会要求
<strong>Java编译器在生成指令序列时，插入特定类型的内存屏障(Memory Barriers)指令</strong>，通过内存屏障来禁止特定类型的处理器重排序。</p>

<p>　　JMM属于语言级的内存模型(Java Memory Model)，它确保在不同的编译器和不同的处理器平台上，通过禁止特定类型的编译器重
排序和处理器重排序，为程序员提供一致的内存可见性保证。</p>

<p>　　现在处理器都有各自的写缓冲区，临时保存向内存中写入的数据。这样，保证处理器不用等待向内存中写入数据，可以加快速度。</p>

<p>　　为了保证内存可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止一些处理器重排序，重排序主要包括
Load-Load、Load-Store、Store-Load和Store-Store。相应的内存屏障指令也就是以上四种，它确保某个操作一定在另一个操作
之前。StoreLoad Barriers是一个&rdquo;全能型&rdquo;的屏障，它同时具有其他3个屏障的效果，执行这个屏障的操作比较耗时，它会要求<strong>当前
处理器将写缓冲区的全部数据刷新到内存中</strong>。</p>

<p>　　数据依赖性：两个操作访问了同一个变量，且其中一个操作为写，则这两个操作之间存在数据依赖性，主要分为读后写、写后读、写后写
三种。记住<strong>编译器和处理器在重排序时，遵守数据依赖性，不会改变两个存在数据依赖性操作的执行顺序</strong>。但是仅限于单个处理器中
的执行顺序和单个线程中的执行顺序，不同处理器和不同线程之间的数据依赖性不会被考虑(这也是程序员需要考虑线程安全的原因)。</p>

<p>　　这里有一个比较新的概念，叫做<strong>猜测(Speculation)</strong>，多出现在条件控制语句中。处理器可能会先执行某个if条件后的语句，将执行结果保存在某个临时变量中，当if条件为真时，再将临时变量的值
复制回原操作变量。这也是一种很常见的重排序。因为存在if语句，代码中存在了<strong>控制依赖</strong>，而控制依赖会影响指令序列的执行并行度，猜测是用来提高并行度的。</p>

<p>　　写volatile变量会强制写入主内存，读volatile变量会让当前线程本地内存中的值置位无效，然后强制从主内存中读取。</p>

<p>　　当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。</p>

<p>　　需要<strong><big>深入理解AQS，这是实现Java锁机制的关键，AQS使用一个整型的volatile变量来维护同步状态，这是加锁解锁的关键</big></strong></p>

<p>　　ReentrantLock提供了公平锁和非公平锁两种实现，公平锁和非公平锁的<strong>释放过程</strong>是一样的，都是在最后写volatile状态变量；公平锁获取时，首先会去读volatile变量。非公平锁获取时，首先
会用CAS更新volatile变量，这个操作同时具有volatile读和volatile写的内存语义。</p>

<p>　　如果我们仔细分析concurrent包的源代码实现，会发现一个通用化的实现模式。首先，声明共享变量为volatile。然后，使用CAS的原子条件更新来实现线程之间的同步。再次表明<strong>AQS</strong>的重要性。</p>

<p>　　关于<strong>Final域</strong>的内存语义这一块没有看的明白，但是看到了一条建议，被构造对象的引用在构造函数中没有&rdquo;逸出&rdquo;，这也是
effective Java 中的一条建议之一。</p>

<p>　　happens-before的概念是大名鼎鼎的Lamport在一篇论文中提出的《Time, Clocks and the Ordering of Events In
a Distributed System》，也就是paxos的提出者。Lamport使用happens-before来定义<strong>分布式系统中事件之间的偏序关系。</strong></p>

<p>　　《JSR-133:Java Memory Model and Thread Specification》对happens-before关系的定义如下：</p>

<ul>
<li>1) 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第
二个之前。</li>
<li>2) 两个操作之间存在happens-before关系，<strong>并不意味着</strong>Java平台的具体实现必须要按照happens-before关系指定的顺序
来执行。如果重排序之后的执行结果，与按照happens-before关系来执行的结果一致，那么这种重排序是被允许的。</li>
</ul>

<p>　　上面的1）是JMM对程序员的承诺。从程序员的角度来说，可以这样理解happens-before关系：如果A happens-before B，
那么Java内存模型将向程序员保证——A操作的结果将对B可见，且A的执行顺序排在B之前。注意，这只是Java内存模型向程序员做出的
保证。</p>

<p>　　上面的2）是JMM对编译器和处理器重排序的约束原则。正如前面所言，JMM其实是在遵循一个基本原则：只要不改变程序的执行结果
（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。JMM这么做的原因是：程序员对于这两个操作是否真的
被重排序并不关心，程序员关心的是程序执行时的语义不能被改变（即执行结果不能被改变）。因此，happens-before关系本质上和
as-if-serial语义是一回事。</p>

<p>　　假设线程A在执行的过程中，通过执行ThreadB.start()来启动线程B；同时，假设线程A在执行ThreadB.start()之前修改了一些
共享变量，线程B在开始执行后会读取到这些共享变量；同理，假设线程A在执行的过程中，通过执行ThreadB. join()来等待线程B终
止；同时，假设线程B在终止之前修改了一些共享变量，线程A从ThreadB. join()返回后会读取到这些共享变量。</p>

<p>　　Java语言规范，在首次发生下列任意一种情况时，一个类或接口类型T将被立即初始化：</p>

<ul>
<li>1、T是一个类，而且一个T类型的实例被创建；</li>
<li>2、T是一个类，而且T中声明的一个静态方法被调用；</li>
<li>3、T中声明的一个静态字段被赋值；</li>
<li>4、T中声明的一个静态字段被访问，<strong>而且这个字段不是一个常量字段</strong>，换句话说，如果直接引用一个类的static final常量
时，并不会引发这个类的初始化。准确来说，<strong>这个常量还必须是一个编译期常量</strong>。</li>
<li>5、T是一个顶级类，而且一个断言语句嵌套在T内部被执行。</li>
</ul>

<p>　　对于每一个类或接口C，都有一个唯一的初始化锁LC与之对应。从C到LC的映射，由JVM的具体实现去自由实现。JVM在类初始化期间
会获取这个初始化锁，并且<strong>每个线程至少获取一次锁</strong>来确保这个类已经被初始化过了（事实上，Java语言规范允许JVM的具体实现
在这里做一些优化）。</p>

<p>　　<strong><big>第四章：线程</big></strong></p>

<p>　　我们知道线程的各个状态之间相互切换的法则，这里需要注意一点的是，阻塞状态是线程阻塞在进入synchronized修饰的同步方法时的状态，而&rdquo;阻塞&rdquo;在juc包下的Lock接口中的线程确是<strong>等待</strong>状态。
因为java.concurrent包中Lock接口对于阻塞的实现都是使用LockSupport类中的相关方法。即调用LockSupport.park()方法线程是进入waiting状态，而不是blocking状态。</p>

<p>　　还有一点是，我们知道调用一个对象的wait()方法后(前提是获取到了该对象的锁)，线程会进入waiting状态，并被移入该对象的等待队列，然后释放锁；二另一个线程调用notify()方法会唤醒这个线程，
将前一个线程从等待队列中移出，移入<strong>同步队列</strong>，<strong>状态由waiting—&gt;blocked</strong>，做完这些后，线程不会马上释放锁，而是直到执行完同步块的代码后才会释放锁。</p>

<p>　　管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而<strong>传输的媒介为内存</strong>。管道输入/输出流主要包括了如下4种具体实现：
PipedOutputStream、PipedInputStream、PipedReader和PipedWriter，前两种面向字节，而后两种面向字符。</p>

    </div>

    
    


    
    

    <footer class="post-footer">
      <div class="post-tags">
          <a href="https://monkback.github.io/tags/java%E5%B9%B6%E5%8F%91/">Java并发</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/jvm/jmm/">
            
            <i class="iconfont">
              <svg  class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417 757.434875 204.940602c11.338233-12.190647 11.035334-32.285311-0.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-0.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891 0.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"></path>
</svg>

            </i>
            <span class="prev-text nav-default">Java内存模型</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/algorithm/array-linkedlist/">
            <span class="next-text nav-default">Array LinkedList</span>
            <span class="prev-text nav-mobile">Next</span>
            
            <i class="iconfont">
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

            </i>
          </a>
      </nav>
    </footer>
  </article>

  
  

  
  

  

  
  

  

  

  

    

  

        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="icon-links">
  


<a href="https://monkback.github.io/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
   
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    
      2017 -
    2020
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span></span>

  
  

  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.dee43230127a73d039a734510fa896c89c3c7ce0cf0be0c7a7433f8fd69b76dc.js" integrity="sha256-3uQyMBJ6c9A5pzRRD6iWyJw8fODPC&#43;DHp0M/j9abdtw=" crossorigin="anonymous"></script>


























</body>
</html>
