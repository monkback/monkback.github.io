<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Records on Records</title>
    <link>https://monkback.github.io/</link>
    <description>Recent content in Records on Records</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 03 Sep 2019 18:10:06 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>About</title>
      <link>https://monkback.github.io/about/</link>
      <pubDate>Tue, 03 Sep 2019 18:10:06 +0800</pubDate>
      
      <guid>https://monkback.github.io/about/</guid>
      <description>&lt;p&gt;otherwise fk yourself&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>NIO-1</title>
      <link>https://monkback.github.io/posts/nio1/</link>
      <pubDate>Tue, 03 Sep 2019 18:10:06 +0800</pubDate>
      
      <guid>https://monkback.github.io/posts/nio1/</guid>
      <description>

&lt;p&gt;netty是一个用于客户端和服务器通信的高性能网络通信框架，涉及到跨机器之间的通信，必然离不开I/O，所以我们就从Java 的I/O演变之路开始讨论吧。&lt;br /&gt;
    引出一个话题：什么是I/O，或者这么说，一次I/O究竟发生了哪些事情？我们从三个层面来理解一下I/O：
    1. &lt;strong&gt;从直观上来看&lt;/strong&gt;：I/O是计算机和外部设备之间的数据流动过程。计算机即是我们平日里随处可见的一台机器，外部设备大体上又包括输入设备和输出设备。比如，键盘、鼠标就属于输入设备；显示器属于输出设备。
    2. &lt;strong&gt;从计算机架构的层面来看&lt;/strong&gt;：任何涉及到计算机核心（CPU和内存）与其他设备之间的数据转移就是I/O。本体就是计算机核心（CPU和内存）。例如从硬盘上读取数据到内存，是一次输入，将内存中的数据写入到硬盘就产生了输出。在计算机的世界里，这就是I/O的本质。
    3. &lt;strong&gt;从程序员编程的角度来看&lt;/strong&gt;：此时，I/O的主体是我们编写的应用程序（即进程），需要注意的是，我们编写的应用程序其实并不存在实质的I/O过程，真正的I/O是操作系统的任务（用户态和内核态）。我们将应用程序代码的I/O细分为两个动作：I/O调用和I/O执行。I/O调用由应用程序（进程）发起的，而I/O执行是操作系统完成的（这就是&lt;strong&gt;系统调用&lt;/strong&gt;），我们代码里写一个read()函数，实质上包含了我们程序发起的I/O调用，在看不见的地方，还有一次I/O执行（操作系统所完成的系统调用）。
       I/O调用的目的是将进程的内部数据迁移到外部即输出，或将外部数据迁移到进程内部即输入(&lt;strong&gt;应用程序是主体&lt;/strong&gt;)。这里，外部数据指非进程空间数据，在编程时，通常讨论的场景是来自外部存储设备的数据，如硬盘、CD-ROM、以及需要socket通信传输的网络数据。
    我们来看一次典型的I/O输入会发生什么事情，以一个进程的输入类型的IO调用为例，它的工作内容如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;进程向操作系统请求外部数据——&amp;gt;I/O调用&lt;/li&gt;
&lt;li&gt;操作系统将外部数据加载到&lt;strong&gt;内核缓冲区&lt;/strong&gt;———&amp;gt;I/O执行&lt;/li&gt;
&lt;li&gt;操作系统将数据从内核缓冲区&lt;strong&gt;拷贝到进程缓冲区&lt;/strong&gt;———&amp;gt;I/O执行&lt;/li&gt;

&lt;li&gt;&lt;p&gt;进程读取数据继续后面的工作&lt;br /&gt;
接下来我们来对比两组常见的概念&lt;/p&gt;

&lt;h3 id=&#34;阻塞i-o和非阻塞i-o&#34;&gt;阻塞I/O和非阻塞I/O&lt;/h3&gt;

&lt;p&gt;阻塞和非阻塞强调的是进程对于操作系统IO是否处于就绪状态的处理方式。&lt;br /&gt;
  上面已经说过，应用程序的IO实际是分为两个步骤，IO调用和IO执行。IO调用是由进程发起，IO执行是操作系统的工作。操作系统的IO情况决定了进程IO调用是否能够得到立即响应。如进程发起了读取数据的IO调用，操作系统需要将外部数据拷贝到进程缓冲区，在有数据拷贝到进程缓冲区前，进程缓冲区处于不可读状态，我们称之为操作系统IO未就绪。
  进程的IO调用是否能得到立即执行是需要操作系统IO处于就绪状态的，对于读取数据的操作，如果操作系统IO处于未就绪状态，当前进程或线程如果一直等待直到其就绪，该种IO方式为阻塞IO。如果进程或线程并不一直等待其就绪，而是可以做其他事情，这种方式为非阻塞IO。所以对于非阻塞IO，我们编程时需要经常去轮询就绪状态。&lt;/p&gt;

&lt;h3 id=&#34;同步i-o和异步i-o&#34;&gt;同步I/O和异步I/O&lt;/h3&gt;

&lt;p&gt;我们经常会谈及同步IO和异步IO。同步和异步描述的是针对当前执行线程、或进程而言，发起IO调用后，当前线程或进程是否挂起等待操作系统的IO执行完成。
  我们说一个IO执行是同步执行的，意思是程序发起IO调用，当前线程或进程需要等待操作系统完成IO工作并告知进程已经完成，线程或进程才能继续往下执行其他既定指令。
  如果说一个IO执行是异步的，意思是该动作是由当前线程或进程请求发起，且当前线程或进程不必等待操作系统IO的执行完毕，可直接继续往下执行其他既定指令。操作系统完成IO后，当前线程或进程会得到操作系统的通知。
  以一个读取数据的IO操作而言，在操作系统将外部数据写入进程缓冲区这个期间，进程或线程挂起等待操作系统IO执行完成的话，这种IO执行策略就为同步，如果进程或线程并不挂起而是继续工作，这种IO执行策略便为异步。&lt;/p&gt;

&lt;h4 id=&#34;总结-在io调用时-对待操作系统io就绪状态的不同方式-决定了其是阻塞或非阻塞模式-在io执行时-线程或进程是否挂起等待io执行决定了其是否为同步或异步io&#34;&gt;总结：在IO调用时，对待操作系统IO就绪状态的不同方式，决定了其是阻塞或非阻塞模式；在IO执行时，线程或进程是否挂起等待IO执行决定了其是否为同步或异步IO。&lt;/h4&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在JDK引进NIO（Non-Blocking IO）之前，Java的I/O是阻塞式，都是面向流的，大体上可以分为两类：&lt;br /&gt;
 - 基于字节流的InputStream和OutputStream&lt;br /&gt;
 - 基于字符流的Reader和Writer&lt;br /&gt;
  字符和字节之间的转换对应的就是编码和解码。在这个时期Java的IO是同步阻塞的（attention：同步和阻塞不是一个概念，他们是不同维度的），且只有输出流和输入流，没有channe、buffer等，效率很低。
&lt;a href=&#34;https://book.douban.com/subject/1433583/&#34; title=&#34;Java NIO&#34;&gt;Java NIO中文版&lt;/a&gt;这本书剖析了Java NIO，清晰易懂，推荐阅读。&lt;br /&gt;
这里，我们借用权威书《UNIX 网络编程：卷一》中的内容，来讨论Linux下的5种I/O模型。&lt;/p&gt;

&lt;p&gt;对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所有等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用程序缓冲区。 好，下面我们以阻塞套接字的recvfrom的的调用图来说明。&lt;/p&gt;

&lt;p&gt;###1、阻塞I/O模型&lt;br /&gt;
   如图所示，这是最常用的I/O模型，缺省情况下所有的文件操作都是阻塞的，事实上，网络I/O也是文件I/O的一种（SocketOutputStream是FileOutputStream的子类）。在进程空间发起recvfrom调用（&lt;strong&gt;一次I/O调用&lt;/strong&gt;）；此时转到操作系统内核，操作系统内核将数据加载到内核缓冲区（&lt;strong&gt;一次I/O执行&lt;/strong&gt;），这段时间应用进程阻塞住，等待数据准备好；然后由操作系统将数据从内核缓冲区拷贝至用户进程缓冲区（&lt;strong&gt;I/O执行&lt;/strong&gt;），这段时间应用进程仍然处于阻塞状态，等待数据拷贝完成；一旦拷贝完成，操作系统内核就告知用户进程，调用成功返回。由此图我们可以得知，阻塞I/O模型在两个时间段都是被阻塞的。
&lt;a href=&#34;https://imgchr.com/i/AJAlVS&#34;&gt;&lt;img src=&#34;https://s2.ax1x.com/2019/03/23/AJAlVS.png&#34; alt=&#34;AJAlVS.png&#34; /&gt;&lt;/a&gt;
###2、非阻塞I/O模型&lt;br /&gt;
   还是截了一张书中的图，可以看到，应用进程在发起recvfrom调用的时候，如果发现操作系统内核还没有把数据准备好（即操作系统内核缓冲区中还没有数据），那么就直接返回一个EWOULDBLOCK错误，这种模式的一个问题就是你需要隔段时间去轮询一次，看操作系统内核缓冲区中是否有数据到来；一旦内核缓冲区准备好数据，那么调用开始阻塞，等待操作系统将内核缓冲区中的数据拷贝到用户空间中去，这段时间进程仍然是被阻塞住的，直到拷贝完成才能返回。&lt;br /&gt;
   &lt;strong&gt;由此我们得出结论：阻塞和非阻塞I/O的区别在于是否需要等待操作系统将外部数据加载到内核缓冲区&lt;/strong&gt;，即前面提到的第一次I/O执行。
&lt;a href=&#34;https://imgchr.com/i/AtJa11&#34;&gt;&lt;img src=&#34;https://s2.ax1x.com/2019/03/25/AtJa11.png&#34; alt=&#34;AtJa11.png&#34; /&gt;&lt;/a&gt;
###3、I/O多路复用模型&lt;br /&gt;
   I/O多路复用的基本原理是：将多个I/O的阻塞复用到对一个select的阻塞上，实现一个线程处理多个请求，它的核心在于多路复用器Selector，多个socket可以注册到一个Selector上，这个selector去轮询它所负责的socket，发现某一个socket的数据准备好了后就返回，然后去执行系统调用recvfrom。图中我们可以看出来，虽然I/O多路复用的函数也是阻塞的，但是其与以上两种还是有不同的，I/O多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用如recvfrom之上（所以两个系统调用，花费也更大，IO多路复用的性能是有可能比BIO还差的，但其优势在于处理多个连接，参考C10k问题）。&lt;br /&gt;
   图中显示的系统调用是select，这就不得不引入到我们经典的几个系统调用（select、poll、epoll），这是需要单独的一篇文章来介绍三种调用的不同之处，当然它们的思想都是一致的。&lt;br /&gt;
&lt;a href=&#34;https://wyj.shiwuliang.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SELECT%E3%80%81POLL%E5%92%8CEPOLL%20.html&#34; title=&#34;详解select、epoll&#34;&gt;深入理解select、epoll&lt;/a&gt;   当然最好还是看Linux内核书籍&lt;br /&gt;
   注意：当selector轮询到某一个socket可读时，它返回，然后用户进程执行系统调用recvfrom，&lt;strong&gt;这个时候就又回到了我们的前两种I/O模型&lt;/strong&gt;，此时，往往都采用的是NIO方式，因为尽管select返回了，告知用户进程某个socket可读，但并不告诉我们能读的数据有多少，&lt;strong&gt;甚至并不意味着我们接着调用recvfrom就能读到数据&lt;/strong&gt;，所以I/O多路复用一般得搭配NIO。参考：
&amp;gt;&lt;a href=&#34;https://www.zhihu.com/question/37271342&#34;&gt;为什么 IO 多路复用要搭配非阻塞 IO?&lt;/a&gt;
&amp;gt;&lt;a href=&#34;https://www.zhihu.com/question/23614342&#34;&gt;使用epoll时需要将socket设为非阻塞吗？&lt;/a&gt;
&lt;a href=&#34;https://imgchr.com/i/AttrJH&#34;&gt;&lt;img src=&#34;https://s2.ax1x.com/2019/03/25/AttrJH.png&#34; alt=&#34;AttrJH.png&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;###4、信号驱动模型
摘抄自《权威指南书》，首先开启套接口的信号驱动功能，并通过系统调用sigaction执行一个信号处理函数（此系统调用立即返回，用户进程继续工作）；当数据准备就绪时，就为该进程生成一个SIGIO信号，通过信号回调通知应用进程调用recvfrom接口来读取数据。
&lt;a href=&#34;https://imgchr.com/i/AwYmfU&#34;&gt;&lt;img src=&#34;https://s2.ax1x.com/2019/03/28/AwYmfU.png&#34; alt=&#34;AwYmfU.png&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;###5、异步I/O模型
见识一下什么叫真正的异步I/O模型，直接告知内核开启某个操作，并让内核完成整个流程后（包括将数据准备好——拷贝到内核缓冲区，然后将数据从内和缓冲区复制到用户进程缓冲区）。信号驱动模型由内核通知我们什么时候可以开启一个I/O操作，而异步I/O模型直接告诉我们I/O操作已经完成了。
推荐书：&lt;a href=&#34;https://book.douban.com/subject/1500149/&#34; title=&#34;Unix网络编程&#34;&gt;Unix网络编程&lt;/a&gt;
&lt;a href=&#34;https://imgchr.com/i/AwYa1e&#34;&gt;&lt;img src=&#34;https://s2.ax1x.com/2019/03/28/AwYa1e.png&#34; alt=&#34;AwYa1e.png&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这就是传说中的五种Linux I/O模型，下一篇文章我们详细分析一下I/O多路复用模型，重点关注epoll。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>NIO-2</title>
      <link>https://monkback.github.io/posts/nio2/</link>
      <pubDate>Tue, 03 Sep 2019 18:10:06 +0800</pubDate>
      
      <guid>https://monkback.github.io/posts/nio2/</guid>
      <description>&lt;p&gt;###传统的BIO###
我们先使用一个传统的client/server模式来编写了一段两个进程之间通信的代码。ServerSocke负责绑定ip地址、监听相关的端口，Socket负责发起连接操作；这就是一次典型的tcp三次握手。传统的ServerSocket会阻塞在其accept方法上，直到一个客户端发起了连接，然后accept方法返回一个socket，这个socket就负责和我们客户端进行通信。
本例中，书上采用了每返回一个socket（代表每收到一个客户端的连接），就创建并启动一个线程，去做这些具体的通信操作。这样的坏处很明显，当客户端连接增多时，创建大量的线程，这显然是极大的耗费性能的，不满足我们的高并发需求。很容易，我们就想到了一个解决方案——线程池&lt;/p&gt;

&lt;p&gt;###伪异步I/O###
一个看起来可以解决上面问题的方案——线程池，确实在现实中，无脑上线程池是一个能解决很多问题的方案。即我们在服务端放一个线程池，里面有一定数量的线程，来一个客户端的连接，我们就拿出一个线程去和客户端进行通信。这样看起来就已经很美好了，我们下面来分析一下线程池的弊端，或者这么说，线程池并没有解决本质上处理连接时的阻塞问题。
####弊端：
1、首先，当对socket输入流进行读取操作时，它会一直阻塞，直到有数据可读或者可用数据读完或者抛异常后才会终止；这意味着如果发送方发送请求消息比较慢、或者网络传输比较慢的时候，读取输入流一方的线程将一直被阻塞；（类似于I/O模型中，需要等待操作系统将数据拷贝至内核缓冲区中）。值得注意的是，输入是针对客户端和服务端双方的，大家都既是输入又是输出。
2、当调用outputstream的write方法时写输出流时，它也将被阻塞，直到&lt;strong&gt;所有要发送的字节流被写入完毕，或者发生异常&lt;/strong&gt;，这里我们需要认识到以前学过的TCP拥塞控制，这就是知识的相关性。
所以，我们的线程池只是治标不治本，并不能完全解决底层的同步阻塞问题。&lt;/p&gt;

&lt;p&gt;###NIO编程###
Non-blocking I/O，NIO是Java提供的一个包，里面封装了一些新的概念，让我们可以直接使用，从而无需关心底层I/O的细节。和它相对应的就是之前的java.io包，&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>