<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Records on Records</title>
    <link>https://monkback.github.io/</link>
    <description>Recent content in Records on Records</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 16 Sep 2019 16:35:04 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Spring 4.x 阅读笔记(一)</title>
      <link>https://monkback.github.io/2019/spring-4.x-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B8%80/</link>
      <pubDate>Mon, 16 Sep 2019 16:35:04 +0800</pubDate>
      
      <guid>https://monkback.github.io/2019/spring-4.x-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B8%80/</guid>
      <description>&lt;p&gt;&lt;center&gt;&lt;big&gt;&lt;strong&gt;读《Spring 4.x 》一书记录&lt;/strong&gt;&lt;/big&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第一章 概述&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;提起Spring这个框架，我们都会说到Inverse of Control和Aspect Oriented Programming，我所理解的这是两种思维模式：IOC为了解耦，使得类与类之间的依赖不再通过代码（配置），而AOP用来处理一些面向对象的语言中不太好处理的情况——多个类的横向代码复用（我把继承认为是纵向的复用）。&lt;/p&gt;

&lt;p&gt;在这两大思想的基础上，往外延伸了很多内容，包括数据访问、MVC、事务管理、缓存、web容器、RPC等一系列内容，后面还有Spring Cloud等服务发现、服务治理相关，这些都值得深入学习。
&lt;br&gt;&lt;br/&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br&gt;&lt;/br&gt;
&lt;strong&gt;第二章 通过一个入门实例介绍Spring Web应用的开发过程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;持久层，负责数据的访问以及操作，即相应的Dao类。Spring本身支持多种ORM框架，最简单的我们可以用Spring JDBC，自己写sql，然后执行相关操作。&lt;/p&gt;

&lt;p&gt;先建立好相关的实体类，也叫领域对象，它们往往和数据库中的一张表的相关字段一一对应，但对于一个稍微复杂的应用可能就不完全是数据库中的表了。这个类一般需要支持序列化，即会在网络上传输。&lt;/p&gt;

&lt;p&gt;Spring中在Dao类上增加@Repository注解，标识定义了一个Bean实体（后面我们会知道，还有@Controller等注解），然后在局部变量jdbcTemplate上增加@Autowired注解，将jdbcTemplate这个Bean自动注入到Dao类中，这里便体现了Spring的Dependency Injection。
当然，下面两种方式均支持：1、直接在局部变量上增加注解；2、单独写一个set方法，在方法级别上增加注解&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Autowired
private JdbcTemplate jdbcTemplate;

@Autowired
public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {
    this.jdbcTemplate = jdbcTemplate;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面使用了注解的方式来定义Bean，在老一些版本的Spring中，使用XML配置方式来定义Bean，显然注解的方式更加简单。另外，jdbcTemplate对传统的JDBC API进行了封装。&lt;/p&gt;

&lt;p&gt;相关的配置文件内容如下：扫描指定包下所有类，这样这些类中定义的相关Spring注解(@Repository、@Autowired)才能生效；配置好MySQL相应的连接，定义连接源 Bean；将dataSource注入到
jdbcTemplate中(这里就是一种XML方式的注入)，而jdbcTemplate这个Bean是通过注解的方式注入到了Dao类中，这就是注解配置和XML配置的结合。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 扫描类包，将标注Spring注解的类自动转化Bean，同时完成Bean的注入 --&amp;gt;
    &amp;lt;context:component-scan base-package=&amp;quot;com.smart.dao&amp;quot;/&amp;gt;
&amp;lt;!-- 配置数据源 --&amp;gt;
    &amp;lt;bean id=&amp;quot;dataSource&amp;quot; class=&amp;quot;org.apache.commons.dbcp.BasicDataSource&amp;quot;
          destroy-method=&amp;quot;close&amp;quot;
          p:driverClassName=&amp;quot;com.mysql.jdbc.Driver&amp;quot;
          p:url=&amp;quot;xxx&amp;quot;
          p:username=&amp;quot;xxx&amp;quot;
          p:password=&amp;quot;xxx&amp;quot; /&amp;gt;

&amp;lt;!-- 配置Jdbc模板  --&amp;gt;
&amp;lt;bean id=&amp;quot;jdbcTemplate&amp;quot; class=&amp;quot;org.springframework.jdbc.core.JdbcTemplate&amp;quot;
    p:dataSource-ref=&amp;quot;dataSource&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;业务层，和Dao类类似，Spring在Service类上增加@Service注解，标识这是一个服务Bean，接着注入Dao层的Bean，同理，如下两种方式二选一即可。还可以在方法上增加@Transactional注解，标识让该
方法运行在事务环境中(当然还需要额外的配置)。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Autowired
private UserDao userDao;

@Autowired
public void setUserDao(UserDao userDao) {
    this.userDao = userDao;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;针对service层的相关配置如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 配置事务管理器 --&amp;gt;
&amp;lt;bean id=&amp;quot;transactionManager&amp;quot;
    class=&amp;quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&amp;quot;
    p:dataSource-ref=&amp;quot;dataSource&amp;quot; /&amp;gt;

&amp;lt;!-- 通过AOP配置提供事务增强，让service包下所有Bean的所有标有Transactional注解的方法拥有事务 --&amp;gt;
&amp;lt;aop:config proxy-target-class=&amp;quot;true&amp;quot;&amp;gt;
    &amp;lt;aop:pointcut id=&amp;quot;serviceMethod&amp;quot;
        expression=&amp;quot;(execution(* com.smart.service..*(..))) and (@annotation(org.springframework.transaction.annotation.Transactional))&amp;quot; /&amp;gt;
    &amp;lt;aop:advisor pointcut-ref=&amp;quot;serviceMethod&amp;quot; advice-ref=&amp;quot;txAdvice&amp;quot; /&amp;gt;
&amp;lt;/aop:config&amp;gt;
&amp;lt;tx:advice id=&amp;quot;txAdvice&amp;quot; transaction-manager=&amp;quot;transactionManager&amp;quot;&amp;gt;
    &amp;lt;tx:attributes&amp;gt;
        &amp;lt;tx:method name=&amp;quot;*&amp;quot; /&amp;gt;
    &amp;lt;/tx:attributes&amp;gt;
&amp;lt;/tx:advice&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;展现层的复杂之处在于web.xml中的相关配置，以便在web容器启动时能够自动启动Spring容器，包括以下几个点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;context-param里指定Spring配置文件的路径&lt;/li&gt;
&lt;li&gt;负责启动Spring容器的监听器，可以获取Spring配置文件的地址；这个监听器会在web容器启动时自动运行，并根据上面的Spring配置
文件参数，来启动Spring容器&lt;/li&gt;
&lt;li&gt;配置Spring MVC的相关信息。通过一个servlet来获取URL请求，并根据请求进行不同处理。指定servlet-name servlet-mapping&lt;/li&gt;
&lt;li&gt;根据上一步声明的servlet名，Spring MVC还需要一个&lt;servlet 名&gt;-servlet.xml的配置文件，里面内容如下

&lt;ul&gt;
&lt;li&gt;扫描web包，应用Spring的注解 context:component-scan base-package=&amp;ldquo;com.smart.web&amp;rdquo;/&lt;/li&gt;
&lt;li&gt;配置视图解析器，将ModelAndView及字符串解析为具体的页面&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;针对Controller层的代码，Spring习惯在类上增加@controller注解，标识这个类是一个Spring MVC的控制器，这个控制器拥有不同
的方法来处理不同的HTTP请求，这一点是通过@RequestMappping注解来指定路径，这个方法可以返回一个ModelAndView(既包含视图信息，
又包括视图渲染所需的模型数据信息)，也可以仅返回数据&lt;/p&gt;

&lt;p&gt;这里还有一部分前端的知识，就不梳理了
&lt;br&gt;&lt;/br&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br&gt;&lt;/br&gt;
&lt;strong&gt;第三章 Spring Boot的开发流程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;总体上Spring Boot封装了Spring开发中的很多繁琐的配置工作，简化了Spring应用的开发流程。它主要借助了Groovy语言来搞定
复杂的配置内容，主要优点有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;相对于传统的Spring项目，更加简洁，封装的内容更多&lt;/li&gt;
&lt;li&gt;内嵌了Jetty和Tomcat容器，无需部署一个war包到web容器中，可以直接运行&lt;/li&gt;
&lt;li&gt;提供了基于Maven的pom配置模板来简化工程的配置&lt;/li&gt;
&lt;li&gt;提供了性能指标，应用健康程度检查&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Spring Boot是由一系列启动器组成的，我们可以根据自己项目的需要，组合不同的启动器，来快速搭建项目的基础运行框架。&lt;/p&gt;

&lt;p&gt;一般上，我们可以在自己的pom文件中用parent节点来继承Spring Boot的默认配置(这是Spring Boot提供的pom跟配置)；
然后根据应用需要再添加不同类型的启动器依赖；最后配置一个Spring Boot运行插件，方便IDEA中使用。&lt;/p&gt;

&lt;p&gt;Spring框架提供了几种可选的数据库操作方式，比如：Spring内置轻量级的jdbcTemplate，也可以使用第三方的持久化框架，比如
Hibernate或MyBaits。Spring Boot为这两种操作数据库的方式分别提供了各自的启动器：spring-boot-starter-jdbc和
spring-boot-starter-jpa。&lt;/p&gt;

&lt;p&gt;导入了相关的依赖包以后，为了让Spring Boot能够自动装配数据源的连接，需要创建一个properties文件，存放数据库的连接信息。
Dao层的代码和第二章一样，不同的是，现在无须在Spring配置文件中装配Bean了，不用定义扫描包等，boot已经帮我们做了这些工作。&lt;/p&gt;

&lt;p&gt;Service层代码也和之前一致，但在支持事务时，boot中需要我们在启动类Application上增加@EnableTransactionManagement注解，
来启用注解事务管理，也比之前繁琐的配置简单了不少；当然，用户也可以自定义事务管理器，在Application类下添加自定义事务管理器方法
txManager()，如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  @Bean
  public PlatformTransactionManager txManager(DataSource dataSource) {
      return new DataSourceTransactionManager(dataSource);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Spring Boot默认还提供了对应用本身、数据库连接、Redis、ES、MQ等服务的健康状态的检测功能，这里就不细说了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://monkback.github.io/about/</link>
      <pubDate>Tue, 03 Sep 2019 18:10:06 +0800</pubDate>
      
      <guid>https://monkback.github.io/about/</guid>
      <description>&lt;p&gt;&lt;center&gt;&lt;strong&gt;Otherwise fk yourself&lt;/strong&gt;&lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>NIO-1</title>
      <link>https://monkback.github.io/2019/nio-1/</link>
      <pubDate>Tue, 03 Sep 2019 18:10:06 +0800</pubDate>
      
      <guid>https://monkback.github.io/2019/nio-1/</guid>
      <description>

&lt;p&gt;netty是一个用于客户端和服务器通信的高性能网络通信框架，涉及到跨机器之间的通信，必然离不开I/O，所以我们就从Java 的I/O演变之路开始讨论吧。&lt;br /&gt;
    引出一个话题：什么是I/O，或者这么说，一次I/O究竟发生了哪些事情？我们从三个层面来理解一下I/O：
    1. &lt;strong&gt;从直观上来看&lt;/strong&gt;：I/O是计算机和外部设备之间的数据流动过程。计算机即是我们平日里随处可见的一台机器，外部设备大体上又包括输入设备和输出设备。比如，键盘、鼠标就属于输入设备；显示器属于输出设备。
    2. &lt;strong&gt;从计算机架构的层面来看&lt;/strong&gt;：任何涉及到计算机核心（CPU和内存）与其他设备之间的数据转移就是I/O。本体就是计算机核心（CPU和内存）。例如从硬盘上读取数据到内存，是一次输入，将内存中的数据写入到硬盘就产生了输出。在计算机的世界里，这就是I/O的本质。
    3. &lt;strong&gt;从程序员编程的角度来看&lt;/strong&gt;：此时，I/O的主体是我们编写的应用程序（即进程），需要注意的是，我们编写的应用程序其实并不存在实质的I/O过程，真正的I/O是操作系统的任务（用户态和内核态）。我们将应用程序代码的I/O细分为两个动作：I/O调用和I/O执行。I/O调用由应用程序（进程）发起的，而I/O执行是操作系统完成的（这就是&lt;strong&gt;系统调用&lt;/strong&gt;），我们代码里写一个read()函数，实质上包含了我们程序发起的I/O调用，在看不见的地方，还有一次I/O执行（操作系统所完成的系统调用）。
       I/O调用的目的是将进程的内部数据迁移到外部即输出，或将外部数据迁移到进程内部即输入(&lt;strong&gt;应用程序是主体&lt;/strong&gt;)。这里，外部数据指非进程空间数据，在编程时，通常讨论的场景是来自外部存储设备的数据，如硬盘、CD-ROM、以及需要socket通信传输的网络数据。
    我们来看一次典型的I/O输入会发生什么事情，以一个进程的输入类型的IO调用为例，它的工作内容如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;进程向操作系统请求外部数据——&amp;gt;I/O调用&lt;/li&gt;
&lt;li&gt;操作系统将外部数据加载到&lt;strong&gt;内核缓冲区&lt;/strong&gt;———&amp;gt;I/O执行&lt;/li&gt;
&lt;li&gt;操作系统将数据从内核缓冲区&lt;strong&gt;拷贝到进程缓冲区&lt;/strong&gt;———&amp;gt;I/O执行&lt;/li&gt;

&lt;li&gt;&lt;p&gt;进程读取数据继续后面的工作&lt;br /&gt;
接下来我们来对比两组常见的概念&lt;/p&gt;

&lt;h3 id=&#34;阻塞i-o和非阻塞i-o&#34;&gt;阻塞I/O和非阻塞I/O&lt;/h3&gt;

&lt;p&gt;阻塞和非阻塞强调的是进程对于操作系统IO是否处于就绪状态的处理方式。&lt;br /&gt;
  上面已经说过，应用程序的IO实际是分为两个步骤，IO调用和IO执行。IO调用是由进程发起，IO执行是操作系统的工作。操作系统的IO情况决定了进程IO调用是否能够得到立即响应。如进程发起了读取数据的IO调用，操作系统需要将外部数据拷贝到进程缓冲区，在有数据拷贝到进程缓冲区前，进程缓冲区处于不可读状态，我们称之为操作系统IO未就绪。
  进程的IO调用是否能得到立即执行是需要操作系统IO处于就绪状态的，对于读取数据的操作，如果操作系统IO处于未就绪状态，当前进程或线程如果一直等待直到其就绪，该种IO方式为阻塞IO。如果进程或线程并不一直等待其就绪，而是可以做其他事情，这种方式为非阻塞IO。所以对于非阻塞IO，我们编程时需要经常去轮询就绪状态。&lt;/p&gt;

&lt;h3 id=&#34;同步i-o和异步i-o&#34;&gt;同步I/O和异步I/O&lt;/h3&gt;

&lt;p&gt;我们经常会谈及同步IO和异步IO。同步和异步描述的是针对当前执行线程、或进程而言，发起IO调用后，当前线程或进程是否挂起等待操作系统的IO执行完成。
  我们说一个IO执行是同步执行的，意思是程序发起IO调用，当前线程或进程需要等待操作系统完成IO工作并告知进程已经完成，线程或进程才能继续往下执行其他既定指令。
  如果说一个IO执行是异步的，意思是该动作是由当前线程或进程请求发起，且当前线程或进程不必等待操作系统IO的执行完毕，可直接继续往下执行其他既定指令。操作系统完成IO后，当前线程或进程会得到操作系统的通知。
  以一个读取数据的IO操作而言，在操作系统将外部数据写入进程缓冲区这个期间，进程或线程挂起等待操作系统IO执行完成的话，这种IO执行策略就为同步，如果进程或线程并不挂起而是继续工作，这种IO执行策略便为异步。&lt;/p&gt;

&lt;h4 id=&#34;总结-在io调用时-对待操作系统io就绪状态的不同方式-决定了其是阻塞或非阻塞模式-在io执行时-线程或进程是否挂起等待io执行决定了其是否为同步或异步io&#34;&gt;总结：在IO调用时，对待操作系统IO就绪状态的不同方式，决定了其是阻塞或非阻塞模式；在IO执行时，线程或进程是否挂起等待IO执行决定了其是否为同步或异步IO。&lt;/h4&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在JDK引进NIO（Non-Blocking IO）之前，Java的I/O是阻塞式，都是面向流的，大体上可以分为两类：&lt;br /&gt;
 - 基于字节流的InputStream和OutputStream&lt;br /&gt;
 - 基于字符流的Reader和Writer&lt;br /&gt;
  字符和字节之间的转换对应的就是编码和解码。在这个时期Java的IO是同步阻塞的（attention：同步和阻塞不是一个概念，他们是不同维度的），且只有输出流和输入流，没有channe、buffer等，效率很低。
&lt;a href=&#34;https://book.douban.com/subject/1433583/&#34; title=&#34;Java NIO&#34;&gt;Java NIO中文版&lt;/a&gt;这本书剖析了Java NIO，清晰易懂，推荐阅读。&lt;br /&gt;
这里，我们借用权威书《UNIX 网络编程：卷一》中的内容，来讨论Linux下的5种I/O模型。&lt;/p&gt;

&lt;p&gt;对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所有等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用程序缓冲区。 好，下面我们以阻塞套接字的recvfrom的的调用图来说明。&lt;/p&gt;

&lt;p&gt;###1、阻塞I/O模型&lt;br /&gt;
   如图所示，这是最常用的I/O模型，缺省情况下所有的文件操作都是阻塞的，事实上，网络I/O也是文件I/O的一种（SocketOutputStream是FileOutputStream的子类）。在进程空间发起recvfrom调用（&lt;strong&gt;一次I/O调用&lt;/strong&gt;）；此时转到操作系统内核，操作系统内核将数据加载到内核缓冲区（&lt;strong&gt;一次I/O执行&lt;/strong&gt;），这段时间应用进程阻塞住，等待数据准备好；然后由操作系统将数据从内核缓冲区拷贝至用户进程缓冲区（&lt;strong&gt;I/O执行&lt;/strong&gt;），这段时间应用进程仍然处于阻塞状态，等待数据拷贝完成；一旦拷贝完成，操作系统内核就告知用户进程，调用成功返回。由此图我们可以得知，阻塞I/O模型在两个时间段都是被阻塞的。
&lt;a href=&#34;https://imgchr.com/i/AJAlVS&#34;&gt;&lt;img src=&#34;https://s2.ax1x.com/2019/03/23/AJAlVS.png&#34; alt=&#34;AJAlVS.png&#34; /&gt;&lt;/a&gt;
###2、非阻塞I/O模型&lt;br /&gt;
   还是截了一张书中的图，可以看到，应用进程在发起recvfrom调用的时候，如果发现操作系统内核还没有把数据准备好（即操作系统内核缓冲区中还没有数据），那么就直接返回一个EWOULDBLOCK错误，这种模式的一个问题就是你需要隔段时间去轮询一次，看操作系统内核缓冲区中是否有数据到来；一旦内核缓冲区准备好数据，那么调用开始阻塞，等待操作系统将内核缓冲区中的数据拷贝到用户空间中去，这段时间进程仍然是被阻塞住的，直到拷贝完成才能返回。&lt;br /&gt;
   &lt;strong&gt;由此我们得出结论：阻塞和非阻塞I/O的区别在于是否需要等待操作系统将外部数据加载到内核缓冲区&lt;/strong&gt;，即前面提到的第一次I/O执行。
&lt;a href=&#34;https://imgchr.com/i/AtJa11&#34;&gt;&lt;img src=&#34;https://s2.ax1x.com/2019/03/25/AtJa11.png&#34; alt=&#34;AtJa11.png&#34; /&gt;&lt;/a&gt;
###3、I/O多路复用模型&lt;br /&gt;
   I/O多路复用的基本原理是：将多个I/O的阻塞复用到对一个select的阻塞上，实现一个线程处理多个请求，它的核心在于多路复用器Selector，多个socket可以注册到一个Selector上，这个selector去轮询它所负责的socket，发现某一个socket的数据准备好了后就返回，然后去执行系统调用recvfrom。图中我们可以看出来，虽然I/O多路复用的函数也是阻塞的，但是其与以上两种还是有不同的，I/O多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用如recvfrom之上（所以两个系统调用，花费也更大，IO多路复用的性能是有可能比BIO还差的，但其优势在于处理多个连接，参考C10k问题）。&lt;br /&gt;
   图中显示的系统调用是select，这就不得不引入到我们经典的几个系统调用（select、poll、epoll），这是需要单独的一篇文章来介绍三种调用的不同之处，当然它们的思想都是一致的。&lt;br /&gt;
&lt;a href=&#34;https://wyj.shiwuliang.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SELECT%E3%80%81POLL%E5%92%8CEPOLL%20.html&#34; title=&#34;详解select、epoll&#34;&gt;深入理解select、epoll&lt;/a&gt;   当然最好还是看Linux内核书籍&lt;br /&gt;
   注意：当selector轮询到某一个socket可读时，它返回，然后用户进程执行系统调用recvfrom，&lt;strong&gt;这个时候就又回到了我们的前两种I/O模型&lt;/strong&gt;，此时，往往都采用的是NIO方式，因为尽管select返回了，告知用户进程某个socket可读，但并不告诉我们能读的数据有多少，&lt;strong&gt;甚至并不意味着我们接着调用recvfrom就能读到数据&lt;/strong&gt;，所以I/O多路复用一般得搭配NIO。参考：
&amp;gt;&lt;a href=&#34;https://www.zhihu.com/question/37271342&#34;&gt;为什么 IO 多路复用要搭配非阻塞 IO?&lt;/a&gt;
&amp;gt;&lt;a href=&#34;https://www.zhihu.com/question/23614342&#34;&gt;使用epoll时需要将socket设为非阻塞吗？&lt;/a&gt;
&lt;a href=&#34;https://imgchr.com/i/AttrJH&#34;&gt;&lt;img src=&#34;https://s2.ax1x.com/2019/03/25/AttrJH.png&#34; alt=&#34;AttrJH.png&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;###4、信号驱动模型
摘抄自《权威指南书》，首先开启套接口的信号驱动功能，并通过系统调用sigaction执行一个信号处理函数（此系统调用立即返回，用户进程继续工作）；当数据准备就绪时，就为该进程生成一个SIGIO信号，通过信号回调通知应用进程调用recvfrom接口来读取数据。
&lt;a href=&#34;https://imgchr.com/i/AwYmfU&#34;&gt;&lt;img src=&#34;https://s2.ax1x.com/2019/03/28/AwYmfU.png&#34; alt=&#34;AwYmfU.png&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;###5、异步I/O模型
见识一下什么叫真正的异步I/O模型，直接告知内核开启某个操作，并让内核完成整个流程后（包括将数据准备好——拷贝到内核缓冲区，然后将数据从内和缓冲区复制到用户进程缓冲区）。信号驱动模型由内核通知我们什么时候可以开启一个I/O操作，而异步I/O模型直接告诉我们I/O操作已经完成了。
推荐书：&lt;a href=&#34;https://book.douban.com/subject/1500149/&#34; title=&#34;Unix网络编程&#34;&gt;Unix网络编程&lt;/a&gt;
&lt;a href=&#34;https://imgchr.com/i/AwYa1e&#34;&gt;&lt;img src=&#34;https://s2.ax1x.com/2019/03/28/AwYa1e.png&#34; alt=&#34;AwYa1e.png&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这就是传说中的五种Linux I/O模型，下一篇文章我们详细分析一下I/O多路复用模型，重点关注epoll。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>NIO-2</title>
      <link>https://monkback.github.io/2019/nio-2/</link>
      <pubDate>Tue, 03 Sep 2019 18:10:06 +0800</pubDate>
      
      <guid>https://monkback.github.io/2019/nio-2/</guid>
      <description>&lt;p&gt;###传统的BIO###
我们先使用一个传统的client/server模式来编写了一段两个进程之间通信的代码。ServerSocke负责绑定ip地址、监听相关的端口，Socket负责发起连接操作；这就是一次典型的tcp三次握手。传统的ServerSocket会阻塞在其accept方法上，直到一个客户端发起了连接，然后accept方法返回一个socket，这个socket就负责和我们客户端进行通信。
本例中，书上采用了每返回一个socket（代表每收到一个客户端的连接），就创建并启动一个线程，去做这些具体的通信操作。这样的坏处很明显，当客户端连接增多时，创建大量的线程，这显然是极大的耗费性能的，不满足我们的高并发需求。很容易，我们就想到了一个解决方案——线程池&lt;/p&gt;

&lt;p&gt;###伪异步I/O###
一个看起来可以解决上面问题的方案——线程池，确实在现实中，无脑上线程池是一个能解决很多问题的方案。即我们在服务端放一个线程池，里面有一定数量的线程，来一个客户端的连接，我们就拿出一个线程去和客户端进行通信。这样看起来就已经很美好了，我们下面来分析一下线程池的弊端，或者这么说，线程池并没有解决本质上处理连接时的阻塞问题。
####弊端：
1、首先，当对socket输入流进行读取操作时，它会一直阻塞，直到有数据可读或者可用数据读完或者抛异常后才会终止；这意味着如果发送方发送请求消息比较慢、或者网络传输比较慢的时候，读取输入流一方的线程将一直被阻塞；（类似于I/O模型中，需要等待操作系统将数据拷贝至内核缓冲区中）。值得注意的是，输入是针对客户端和服务端双方的，大家都既是输入又是输出。
2、当调用outputstream的write方法时写输出流时，它也将被阻塞，直到&lt;strong&gt;所有要发送的字节流被写入完毕，或者发生异常&lt;/strong&gt;，这里我们需要认识到以前学过的TCP拥塞控制，这就是知识的相关性。
所以，我们的线程池只是治标不治本，并不能完全解决底层的同步阻塞问题。&lt;/p&gt;

&lt;p&gt;###NIO编程###
Non-blocking I/O，NIO是Java提供的一个包，里面封装了一些新的概念，让我们可以直接使用，从而无需关心底层I/O的细节。和它相对应的就是之前的java.io包，&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>